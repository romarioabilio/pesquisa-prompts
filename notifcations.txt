Directory structure:
â””â”€â”€ cypress-realworld-app/
    â”œâ”€â”€ codecov.yml
    â”œâ”€â”€ cypress.json
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ package.json
    â”œâ”€â”€ renovate.json
    â”œâ”€â”€ sandbox.config.json
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ tsconfig.tsnode.json
    â”œâ”€â”€ .all-contributorsrc
    â”œâ”€â”€ .node-version
    â”œâ”€â”€ .prettierignore
    â”œâ”€â”€ .prettierrc
    â”œâ”€â”€ backend/
    â”‚   â”œâ”€â”€ app.ts
    â”‚   â”œâ”€â”€ auth.ts
    â”‚   â”œâ”€â”€ bankaccount-routes.ts
    â”‚   â”œâ”€â”€ banktransfer-routes.ts
    â”‚   â”œâ”€â”€ comment-routes.ts
    â”‚   â”œâ”€â”€ contact-routes.ts
    â”‚   â”œâ”€â”€ database.ts
    â”‚   â”œâ”€â”€ helpers.ts
    â”‚   â”œâ”€â”€ like-routes.ts
    â”‚   â”œâ”€â”€ notification-routes.ts
    â”‚   â”œâ”€â”€ testdata-routes.ts
    â”‚   â”œâ”€â”€ transaction-routes.ts
    â”‚   â”œâ”€â”€ types.ts
    â”‚   â”œâ”€â”€ user-routes.ts
    â”‚   â””â”€â”€ validators.ts
    â”œâ”€â”€ cypress/
    â”‚   â”œâ”€â”€ global.d.ts
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”œâ”€â”€ fixtures/
    â”‚   â”‚   â””â”€â”€ public-transactions.json
    â”‚   â”œâ”€â”€ plugins/
    â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â”œâ”€â”€ support/
    â”‚   â”‚   â”œâ”€â”€ commands.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â””â”€â”€ tests/
    â”‚       â””â”€â”€ ui/
    â”‚           â”œâ”€â”€ auth.spec.ts
    â”‚           â”œâ”€â”€ bankaccounts.spec.ts
    â”‚           â”œâ”€â”€ new-transaction.spec.ts
    â”‚           â”œâ”€â”€ notifications.spec.ts
    â”‚           â”œâ”€â”€ transaction-feeds.spec.ts
    â”‚           â”œâ”€â”€ transaction-view.spec.ts
    â”‚           â””â”€â”€ user-settings.spec.ts
    â”œâ”€â”€ data/
    â”‚   â””â”€â”€ empty-seed.json
    â”œâ”€â”€ public/
    â”‚   â”œâ”€â”€ index.html
    â”‚   â”œâ”€â”€ manifest.json
    â”‚   â””â”€â”€ robots.txt
    â”œâ”€â”€ scripts/
    â”‚   â”œâ”€â”€ generateSeedData.ts
    â”‚   â”œâ”€â”€ seedDataUtils.ts
    â”‚   â”œâ”€â”€ testServer.ts
    â”‚   â””â”€â”€ tsconfig.json
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ index.tsx
    â”‚   â”œâ”€â”€ react-app-env.d.ts
    â”‚   â”œâ”€â”€ setupProxy.js
    â”‚   â”œâ”€â”€ __tests__/
    â”‚   â”‚   â”œâ”€â”€ bankaccounts.test.ts
    â”‚   â”‚   â”œâ”€â”€ comments.test.ts
    â”‚   â”‚   â”œâ”€â”€ contacts.test.ts
    â”‚   â”‚   â”œâ”€â”€ generateSeedData.test.ts
    â”‚   â”‚   â”œâ”€â”€ likes.test.ts
    â”‚   â”‚   â”œâ”€â”€ notifications.test.ts
    â”‚   â”‚   â”œâ”€â”€ transactions.test.ts
    â”‚   â”‚   â””â”€â”€ users.test.ts
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”œâ”€â”€ AlertBar.tsx
    â”‚   â”‚   â”œâ”€â”€ BankAccountForm.tsx
    â”‚   â”‚   â”œâ”€â”€ BankAccountItem.tsx
    â”‚   â”‚   â”œâ”€â”€ BankAccountList.tsx
    â”‚   â”‚   â”œâ”€â”€ CommentForm.tsx
    â”‚   â”‚   â”œâ”€â”€ CommentList.tsx
    â”‚   â”‚   â”œâ”€â”€ CommentListItem.tsx
    â”‚   â”‚   â”œâ”€â”€ EmptyList.tsx
    â”‚   â”‚   â”œâ”€â”€ Footer.tsx
    â”‚   â”‚   â”œâ”€â”€ MainLayout.tsx
    â”‚   â”‚   â”œâ”€â”€ NavBar.tsx
    â”‚   â”‚   â”œâ”€â”€ NavDrawer.tsx
    â”‚   â”‚   â”œâ”€â”€ NotificationList.tsx
    â”‚   â”‚   â”œâ”€â”€ NotificationListItem.tsx
    â”‚   â”‚   â”œâ”€â”€ PrivateRoute.tsx
    â”‚   â”‚   â”œâ”€â”€ SignInForm.tsx
    â”‚   â”‚   â”œâ”€â”€ SignUpForm.tsx
    â”‚   â”‚   â”œâ”€â”€ SkeletonList.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionAmount.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionContactsList.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionCreateStepOne.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionCreateStepThree.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionCreateStepTwo.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionDateRangeFilter.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionDetail.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionInfiniteList.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionItem.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionList.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionListAmountRangeFilter.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionListFilters.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionNavTabs.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionPersonalList.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionPublicList.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionTitle.tsx
    â”‚   â”‚   â”œâ”€â”€ UserListItem.tsx
    â”‚   â”‚   â”œâ”€â”€ UserListSearchForm.tsx
    â”‚   â”‚   â”œâ”€â”€ UserSettingsForm.tsx
    â”‚   â”‚   â””â”€â”€ UsersList.tsx
    â”‚   â”œâ”€â”€ containers/
    â”‚   â”‚   â”œâ”€â”€ App.tsx
    â”‚   â”‚   â”œâ”€â”€ BankAccountsContainer.tsx
    â”‚   â”‚   â”œâ”€â”€ NotificationsContainer.tsx
    â”‚   â”‚   â”œâ”€â”€ PrivateRoutesContainer.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionCreateContainer.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionDetailContainer.tsx
    â”‚   â”‚   â”œâ”€â”€ TransactionsContainer.tsx
    â”‚   â”‚   â”œâ”€â”€ UserOnboardingContainer.tsx
    â”‚   â”‚   â””â”€â”€ UserSettingsContainer.tsx
    â”‚   â”œâ”€â”€ machines/
    â”‚   â”‚   â”œâ”€â”€ authMachine.ts
    â”‚   â”‚   â”œâ”€â”€ bankAccountsMachine.ts
    â”‚   â”‚   â”œâ”€â”€ contactsTransactionsMachine.ts
    â”‚   â”‚   â”œâ”€â”€ createTransactionMachine.ts
    â”‚   â”‚   â”œâ”€â”€ dataMachine.ts
    â”‚   â”‚   â”œâ”€â”€ drawerMachine.ts
    â”‚   â”‚   â”œâ”€â”€ notificationsMachine.ts
    â”‚   â”‚   â”œâ”€â”€ personalTransactionsMachine.ts
    â”‚   â”‚   â”œâ”€â”€ publicTransactionsMachine.ts
    â”‚   â”‚   â”œâ”€â”€ snackbarMachine.ts
    â”‚   â”‚   â”œâ”€â”€ transactionDetailMachine.ts
    â”‚   â”‚   â”œâ”€â”€ transactionFiltersMachine.ts
    â”‚   â”‚   â”œâ”€â”€ userOnboardingMachine.ts
    â”‚   â”‚   â””â”€â”€ usersMachine.ts
    â”‚   â”œâ”€â”€ models/
    â”‚   â”‚   â”œâ”€â”€ bankaccount.ts
    â”‚   â”‚   â”œâ”€â”€ banktransfer.ts
    â”‚   â”‚   â”œâ”€â”€ comment.ts
    â”‚   â”‚   â”œâ”€â”€ contact.ts
    â”‚   â”‚   â”œâ”€â”€ db-schema.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ like.ts
    â”‚   â”‚   â”œâ”€â”€ notification.ts
    â”‚   â”‚   â”œâ”€â”€ transaction.ts
    â”‚   â”‚   â””â”€â”€ user.ts
    â”‚   â””â”€â”€ utils/
    â”‚       â”œâ”€â”€ asyncUtils.ts
    â”‚       â”œâ”€â”€ historyUtils.ts
    â”‚       â”œâ”€â”€ transactionUtils.ts
    â”‚       â””â”€â”€ __tests__/
    â”‚           â””â”€â”€ transactionUtils.test.ts
    â””â”€â”€ .circleci/
        â””â”€â”€ config.yml

================================================
FILE: cypress-realworld-app/codecov.yml
================================================
codecov:
  require_ci_to_pass: yes

coverage:
  precision: 2
  round: nearest
  range: "90...100"
  status:
    project:
      default:
        base: auto
        target: auto
        threshold: 0.1%
        if_not_found: success
    backend:
      paths:
        - backend
    frontend:
      paths:
        - src

comment:
  layout: "reach,diff,flags,tree"
  behavior: default



================================================
FILE: cypress-realworld-app/cypress.json
================================================
{
  "baseUrl": "http://localhost:3000",
  "projectId": "7s5okt",
  "integrationFolder": "cypress/tests",
  "viewportHeight": 1000,
  "viewportWidth": 1280,
  "firefoxGcInterval": null,
  "retries": {
    "runMode": 2,
    "openMode": 1
  },
  "env": {
    "apiUrl": "http://localhost:3001",
    "mobileViewportWidthBreakpoint": 414,
    "coverage": false,
    "codeCoverage": {
      "url": "http://localhost:3001/__coverage__"
    }
  }
}



================================================
FILE: cypress-realworld-app/LICENSE
================================================
  
MIT License

Copyright (c) 2020 Cypress.io

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: cypress-realworld-app/package.json
================================================
{
  "name": "cypress-realworld-app",
  "version": "1.0.0",
  "description": "A payment application to demonstrate **real-world** usage of Cypress testing methods, patterns, and workflows. For a full reference of our documentation, go to https://docs.cypress.io",
  "repository": {
    "type": "git",
    "url": "https://github.com/cypress-io/cypress-realworld-app.git"
  },
  "author": "Cypress DX Team",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/cypress-io/cypress-realworld-app/issues"
  },
  "engines": {
    "node": ">=12"
  },
  "dependencies": {
    "@babel/cli": "7.11.6",
    "@babel/core": "7.11.6",
    "@babel/preset-env": "7.11.5",
    "@material-ui/core": "4.11.0",
    "@material-ui/icons": "4.9.1",
    "@material-ui/lab": "4.0.0-alpha.56",
    "@percy/cypress": "2.3.2",
    "@types/bcryptjs": "2.4.2",
    "@types/bluebird": "3.5.32",
    "@types/connect-flash": "0.0.35",
    "@types/cors": "2.8.8",
    "@types/dinero.js": "1.6.5",
    "@types/express": "4.17.2",
    "@types/express-paginate": "1.0.0",
    "@types/express-serve-static-core": "4.17.2",
    "@types/express-session": "1.17.0",
    "@types/faker": "5.1.2",
    "@types/jest": "26.0.14",
    "@types/json-server": "0.14.2",
    "@types/lodash": "4.14.162",
    "@types/lowdb": "1.0.9",
    "@types/morgan": "1.9.1",
    "@types/node": "14.11.8",
    "@types/passport": "1.0.4",
    "@types/react": "16.9.53",
    "@types/react-dom": "16.9.8",
    "@types/react-infinite-calendar": "2.3.5",
    "@types/react-router": "5.1.8",
    "@types/react-router-dom": "5.1.6",
    "@types/react-virtualized": "9.21.10",
    "@types/shortid": "0.0.29",
    "@types/uuid": "8.3.0",
    "@types/validator": "13.1.0",
    "@types/webpack-env": "1.15.3",
    "@types/yup": "0.29.8",
    "@xstate/react": "0.8.1",
    "axios": "0.20.0",
    "bcryptjs": "2.4.3",
    "concurrently": "5.3.0",
    "cors": "2.8.5",
    "cross-env": "7.0.2",
    "date-fns": "2.16.1",
    "dinero.js": "1.8.1",
    "dotenv": "8.2.0",
    "express-paginate": "1.0.2",
    "express-session": "1.17.1",
    "express-validator": "6.6.1",
    "faker": "5.1.0",
    "formik": "2.2.0",
    "fuse.js": "6.4.1",
    "husky": "4.3.0",
    "json": "10.0.0",
    "lowdb": "1.0.0",
    "morgan": "1.10.0",
    "ncp": "2.0.0",
    "nodemon": "2.0.4",
    "passport": "0.4.1",
    "passport-local": "1.0.0",
    "react": "16.13.1",
    "react-dom": "16.13.1",
    "react-infinite-calendar": "2.3.1",
    "react-number-format": "4.4.1",
    "react-router": "5.2.0",
    "react-router-dom": "5.2.0",
    "react-scripts": "3.4.0",
    "react-virtualized": "9.22.2",
    "shortid": "2.2.15",
    "ts-node": "9.0.0",
    "typescript": "4.0.3",
    "uuid": "8.3.1",
    "xstate": "4.13.0",
    "yup": "0.29.3"
  },
  "devDependencies": {
    "@cypress/code-coverage": "3.8.2",
    "@cypress/instrument-cra": "1.3.2",
    "@types/connect-history-api-fallback": "1.3.3",
    "@types/http-proxy-middleware": "0.19.3",
    "babel-loader": "8.0.6",
    "cypress": "5.4.0",
    "eslint-config-prettier": "6.12.0",
    "eslint-plugin-cypress": "2.11.2",
    "eslint-plugin-prettier": "3.1.4",
    "istanbul-lib-coverage": "3.0.0",
    "nyc": "15.1.0",
    "prettier": "2.1.2",
    "start-server-and-test": "1.11.5"
  },
  "resolutions": {
    "@babel/compat-data": "7.9.0",
    "@types/express": "4.17.2",
    "@types/express-serve-static-core": "4.17.2"
  },
  "scripts": {
    "dev": "cross-env NODE_ENV=development concurrently yarn:start:react yarn:start:api:watch",
    "start": "cross-env NODE_ENV=development concurrently yarn:start:react yarn:start:api",
    "start:ci": "cross-env NODE_ENV=test concurrently yarn:start:react yarn:start:api",
    "start:react": "react-scripts -r @cypress/instrument-cra start",
    "start:empty": "cross-env NODE_ENV=development EMPTY_SEED=true concurrently yarn:start:react yarn:start:api:watch",
    "list:dev:users": "cat data/database.json | json -a users | json -a id username",
    "types": "tsc --noEmit",
    "cypress:open": "cypress open",
    "cypress:open:mobile": "cypress open --config viewportWidth=375,viewportHeight=667",
    "cypress:run": "cypress run",
    "cypress:run:mobile": "cypress run --config viewportWidth=375,viewportHeight=667",
    "test": "yarn cypress:open",
    "test:headless": "yarn cypress:run",
    "test:api": "yarn cypress:run --spec 'integration/api/*'",
    "test:unit": "react-scripts test --runInBand",
    "test:unit:ci": "react-scripts test --watch false --runInBand",
    "start:api": "yarn tsnode --files backend/app.ts",
    "start:api:watch": "nodemon --exec yarn tsnode --watch 'backend' backend/app.ts",
    "start:react:proxy-server": "yarn tsnode scripts/testServer.ts",
    "prettier": "prettier --write '**/**.{ts,js,tsx}' '*.{json,md,yml}'",
    "tsnode": "nyc --silent ts-node -P tsconfig.tsnode.json",
    "tsnode:not-instrumented": "ts-node -P tsconfig.tsnode.json",
    "db:seed": "yarn tsnode scripts/generateSeedData",
    "db:seed:dev": "ncp ./data/database-seed.json ./data/database.json",
    "db:seed:empty": "ncp ./data/empty-seed.json ./data/database.json",
    "postdb:seed": "yarn db:seed:dev",
    "prestart": "yarn db:seed:dev",
    "predev": "yarn db:seed:dev",
    "prestart:empty": "yarn db:seed:empty",
    "prebuild": "yarn types",
    "build": "react-scripts build",
    "eject": "react-scripts eject",
    "codesandbox:start:api": "yarn tsnode:not-instrumented --files backend/app.ts",
    "codesandbox:start": "NODE_ENV=development TSC_COMPILE_ON_ERROR=true concurrently \"react-scripts start\" yarn:start:api:codesandbox"
  },
  "eslintConfig": {
    "env": {
      "cypress/globals": true
    },
    "extends": [
      "react-app",
      "plugin:prettier/recommended",
      "plugin:cypress/recommended"
    ],
    "plugins": [
      "cypress",
      "prettier"
    ],
    "rules": {
      "no-unused-expressions": 0
    }
  },
  "jest": {
    "watchPathIgnorePatterns": [
      "<rootDir>/data/database.json",
      "<rootDir>/data/database-seed.json"
    ]
  },
  "husky": {
    "hooks": {
      "pre-push": "yarn types"
    }
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "percy": {
    "version": 1,
    "snapshot": {
      "widths": [
        1280
      ]
    }
  },
  "nyc": {
    "exclude": [
      "src/models/*.ts"
    ],
    "reporter": [
      "html",
      "json"
    ]
  }
}



================================================
FILE: cypress-realworld-app/renovate.json
================================================
{
  "extends": ["config:base"],
  "baseBranch": "develop",
  "automerge": false,
  "commitMessage": "{{semanticPrefix}}Update {{depName}} to {{newVersion}} ðŸŒŸ",
  "prTitle": "{{semanticPrefix}}{{#if isPin}}Pin{{else}}Update{{/if}} dependency {{depName}} to version {{#if isRange}}{{newVersion}}{{else}}{{#if isMajor}}{{newVersionMajor}}.x{{else}}{{newVersion}}{{/if}}{{/if}} ðŸŒŸ",
  "major": {
    "automerge": false
  },
  "minor": {
    "automerge": false
  },
  "prHourlyLimit": 1,
  "updateNotScheduled": false,
  "timezone": "America/New_York",
  "lockFileMaintenance": {
    "enabled": true
  },
  "masterIssue": true,
  "schedule": ["every weekend"],
  "packageRules": [
    {
      "packageNames": ["cypress"],
      "schedule": ["every weekday"]
    },
    {
      "packageNames": ["@babel/compat-data"],
      "allowedVersions": "7.9.0"
    },
    {
      "packageNames": ["babel-loader"],
      "allowedVersions": "8.0.6"
    },
    {
      "packageNames": ["react-scripts"],
      "allowedVersions": "3.4.0"
    },
    {
      "packageNames": ["@types/express"],
      "allowedVersions": "4.17.2"
    },
    {
      "packageNames": ["@types/express-serve-static-core"],
      "allowedVersions": "4.17.2"
    }
  ]
}



================================================
FILE: cypress-realworld-app/sandbox.config.json
================================================
{
  "infiniteLoopProtection": true,
  "hardReloadOnChange": false,
  "template": "node",
  "container": {
    "port": 3000,
    "startScript": "start:codesandbox"
  }
}



================================================
FILE: cypress-realworld-app/tsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": "src",
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react"
  },
  "include": ["src", "scripts", "backend", "src/__tests__"]
}



================================================
FILE: cypress-realworld-app/tsconfig.tsnode.json
================================================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "isolatedModules": false
  }
}



================================================
FILE: cypress-realworld-app/.all-contributorsrc
================================================
{
	"files": [
		"README.md"
	],
	"imageSize": 100,
	"commit": false,
	"contributors": [{
			"login": "kevinold",
			"name": "Kevin Old",
			"avatar_url": "https://avatars0.githubusercontent.com/u/21967?v=4",
			"profile": "http://www.kevinold.com",
			"contributions": []
		},
		{
			"login": "amirrustam",
			"name": "Amir Rustamzadeh",
			"avatar_url": "https://avatars0.githubusercontent.com/u/334337?v=4",
			"profile": "https://twitter.com/amirrustam",
			"contributions": []
		},
		{
			"login": "brian-mann",
			"name": "Brian Mann",
			"avatar_url": "https://avatars2.githubusercontent.com/u/1268976?v=4",
			"profile": "https://cypress.io",
			"contributions": []
		},
		{
			"login": "bahmutov",
			"name": "Gleb Bahmutov",
			"avatar_url": "https://avatars1.githubusercontent.com/u/2212006?v=4",
			"profile": "https://glebbahmutov.com/",
			"contributions": []
		},
		{
			"login": "bencodezen",
			"name": "Ben Hong",
			"avatar_url": "https://avatars0.githubusercontent.com/u/4836334?v=4",
			"profile": "http://www.bencodezen.io",
			"contributions": []
		},
		{
			"login": "davidkpiano",
			"name": "David Khourshid",
			"avatar_url": "https://avatars2.githubusercontent.com/u/1093738?v=4",
			"profile": "https://github.com/davidkpiano",
			"contributions": []
		}
	],
	"contributorsPerLine": 7,
	"projectName": "cypress-realworld-app",
	"projectOwner": "cypress-io",
	"repoType": "github",
	"repoHost": "https://github.com",
	"skipCi": true
}


================================================
FILE: cypress-realworld-app/.node-version
================================================
12.19


================================================
FILE: cypress-realworld-app/.prettierignore
================================================
data
build
coverage


================================================
FILE: cypress-realworld-app/.prettierrc
================================================
{
  "trailingComma": "es5",
  "printWidth": 100
}



================================================
FILE: cypress-realworld-app/backend/app.ts
================================================
import express from "express";
import path from "path";
import logger from "morgan";
import passport from "passport";
import session from "express-session";
import bodyParser from "body-parser";
import cors from "cors";
import paginate from "express-paginate";

import auth from "./auth";
import userRoutes from "./user-routes";
import contactRoutes from "./contact-routes";
import bankAccountRoutes from "./bankaccount-routes";
import transactionRoutes from "./transaction-routes";
import likeRoutes from "./like-routes";
import commentRoutes from "./comment-routes";
import notificationRoutes from "./notification-routes";
import bankTransferRoutes from "./banktransfer-routes";
import testDataRoutes from "./testdata-routes";

require("dotenv").config();

const corsOption = {
  origin: "http://localhost:3000",
  credentials: true,
};

const app = express();

/* istanbul ignore next */
// @ts-ignore
if (global.__coverage__) {
  require("@cypress/code-coverage/middleware/express")(app);
}

app.use(cors(corsOption));
app.use(logger("dev"));
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

app.use(
  session({
    secret: "session secret",
    resave: false,
    saveUninitialized: false,
    unset: "destroy",
  })
);
app.use(passport.initialize());
app.use(passport.session());

app.use(paginate.middleware(+process.env.PAGINATION_PAGE_SIZE!));

app.use(auth);
app.use("/users", userRoutes);
app.use("/contacts", contactRoutes);
app.use("/bankAccounts", bankAccountRoutes);
app.use("/transactions", transactionRoutes);
app.use("/likes", likeRoutes);
app.use("/comments", commentRoutes);
app.use("/notifications", notificationRoutes);
app.use("/bankTransfers", bankTransferRoutes);

/* istanbul ignore next */
if (process.env.NODE_ENV === "test" || process.env.NODE_ENV === "development") {
  app.use("/testData", testDataRoutes);
}

app.use(express.static(path.join(__dirname, "../public")));

app.listen(3001);



================================================
FILE: cypress-realworld-app/backend/auth.ts
================================================
import bcrypt from "bcryptjs";
import passport from "passport";
import express, { Request, Response } from "express";
import { User } from "../src/models/user";
import { getUserBy, getUserById } from "./database";

const LocalStrategy = require("passport-local").Strategy;
const router = express.Router();

// configure passport for local strategy
passport.use(
  new LocalStrategy(function (username: string, password: string, done: Function) {
    const user = getUserBy("username", username);

    const failureMessage = "Incorrect username or password.";
    if (!user) {
      return done(null, false, { message: failureMessage });
    }

    // validate password
    if (!bcrypt.compareSync(password, user.password)) {
      return done(null, false, { message: failureMessage });
    }

    return done(null, user);
  })
);

passport.serializeUser(function (user: User, done) {
  done(null, user.id);
});

passport.deserializeUser(function (id: string, done) {
  const user = getUserById(id);
  done(null, user);
});

// authentication routes
router.post("/login", passport.authenticate("local"), (req: Request, res: Response): void => {
  if (req.body.remember) {
    req.session!.cookie.maxAge = 24 * 60 * 60 * 1000 * 30; // Expire in 30 days
  } else {
    req.session!.cookie.expires = false;
  }

  res.send({ user: req.user });
});

router.post("/logout", (req: Request, res: Response): void => {
  res.clearCookie("connect.sid");
  req.logout();
  req.session!.destroy(function (err) {
    res.redirect("/");
  });
});

router.get("/checkAuth", (req, res) => {
  /* istanbul ignore next */
  if (!req.user) {
    res.status(401).json({ error: "User is unauthorized" });
  } else {
    res.status(200).json({ user: req.user });
  }
});

export default router;



================================================
FILE: cypress-realworld-app/backend/bankaccount-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";

import {
  getBankAccountsByUserId,
  getBankAccountById,
  createBankAccountForUser,
  removeBankAccountById,
} from "./database";
import { ensureAuthenticated, validateMiddleware } from "./helpers";
import { shortIdValidation, isBankAccountValidator } from "./validators";
const router = express.Router();

// Routes

//GET /bankAccounts (scoped-user)
router.get("/", ensureAuthenticated, (req, res) => {
  /* istanbul ignore next */
  const accounts = getBankAccountsByUserId(req.user?.id!);

  res.status(200);
  res.json({ results: accounts });
});

//GET /bankAccounts/:bankAccountId (scoped-user)
router.get(
  "/:bankAccountId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("bankAccountId")]),
  (req, res) => {
    const { bankAccountId } = req.params;

    const account = getBankAccountById(bankAccountId);

    res.status(200);
    res.json({ account });
  }
);

//POST /bankAccounts (scoped-user)
router.post("/", ensureAuthenticated, validateMiddleware(isBankAccountValidator), (req, res) => {
  /* istanbul ignore next */
  const account = createBankAccountForUser(req.user?.id!, req.body);

  res.status(200);
  res.json({ account });
});

//DELETE (soft) /bankAccounts (scoped-user)
router.delete(
  "/:bankAccountId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("bankAccountId")]),
  (req, res) => {
    const { bankAccountId } = req.params;

    const account = removeBankAccountById(bankAccountId);

    res.status(200);
    res.json({ account });
  }
);

export default router;



================================================
FILE: cypress-realworld-app/backend/banktransfer-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";

import { getBankTransfersByUserId } from "./database";
import { ensureAuthenticated } from "./helpers";
const router = express.Router();

// Routes

//GET /bankTransfers (scoped-user)
router.get("/", ensureAuthenticated, (req, res) => {
  /* istanbul ignore next */
  const transfers = getBankTransfersByUserId(req.user?.id!);

  res.status(200);
  res.json({ transfers });
});

export default router;



================================================
FILE: cypress-realworld-app/backend/comment-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";
import { getCommentsByTransactionId, createComments } from "./database";
import { ensureAuthenticated, validateMiddleware } from "./helpers";
import { shortIdValidation, isCommentValidator } from "./validators";
const router = express.Router();

// Routes

//GET /comments/:transactionId
router.get(
  "/:transactionId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("transactionId")]),
  (req, res) => {
    const { transactionId } = req.params;
    const comments = getCommentsByTransactionId(transactionId);

    res.status(200);
    res.json({ comments });
  }
);

//POST /comments/:transactionId
router.post(
  "/:transactionId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("transactionId"), isCommentValidator]),
  (req, res) => {
    const { transactionId } = req.params;
    const { content } = req.body;

    /* istanbul ignore next */
    createComments(req.user?.id!, transactionId, content);

    res.sendStatus(200);
  }
);

export default router;



================================================
FILE: cypress-realworld-app/backend/contact-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";

import { getContactsByUsername, removeContactById, createContactForUser } from "./database";
import { ensureAuthenticated, validateMiddleware } from "./helpers";
import { shortIdValidation } from "./validators";
const router = express.Router();

// Routes
//GET /contacts/:username
router.get("/:username", (req, res) => {
  const { username } = req.params;

  const contacts = getContactsByUsername(username);

  res.status(200);
  res.json({ contacts });
});

//POST /contacts (scoped-user)
router.post(
  "/",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("contactUserId")]),
  (req, res) => {
    const { contactUserId } = req.body;
    /* istanbul ignore next */
    const contact = createContactForUser(req.user?.id!, contactUserId);

    res.status(200);
    res.json({ contact });
  }
);
//DELETE /contacts/:contactId (scoped-user)
router.delete(
  "/:contactId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("contactId")]),
  (req, res) => {
    const { contactId } = req.params;

    const contacts = removeContactById(contactId);

    res.status(200);
    res.json({ contacts });
  }
);

export default router;



================================================
FILE: cypress-realworld-app/backend/database.ts
================================================
import path from "path";
import bcrypt from "bcryptjs";
import fs from "fs";
import { v4 } from "uuid";
import {
  uniqBy,
  map,
  sample,
  reject,
  includes,
  orderBy,
  flow,
  flatMap,
  curry,
  get,
  constant,
  filter,
  inRange,
  remove,
} from "lodash/fp";
import { isWithinInterval } from "date-fns";
import low from "lowdb";
import FileSync from "lowdb/adapters/FileSync";
import shortid from "shortid";
import {
  BankAccount,
  Transaction,
  User,
  Contact,
  TransactionStatus,
  TransactionRequestStatus,
  Like,
  Comment,
  PaymentNotification,
  PaymentNotificationStatus,
  LikeNotification,
  CommentNotification,
  NotificationType,
  NotificationPayloadType,
  NotificationsType,
  TransactionResponseItem,
  TransactionPayload,
  BankTransfer,
  BankTransferPayload,
  BankTransferType,
  NotificationResponseItem,
  TransactionQueryPayload,
  DefaultPrivacyLevel,
} from "../src/models";
import Fuse from "fuse.js";
import {
  isPayment,
  getTransferAmount,
  hasSufficientFunds,
  getChargeAmount,
  hasDateQueryFields,
  getDateQueryFields,
  hasAmountQueryFields,
  getAmountQueryFields,
  getQueryWithoutFilterFields,
  getPayAppCreditedAmount,
  isRequestTransaction,
  formatFullName,
  isLikeNotification,
  isCommentNotification,
} from "../src/utils/transactionUtils";
import { DbSchema } from "../src/models/db-schema";

export type TDatabase = {
  users: User[];
  contacts: Contact[];
  bankaccounts: BankAccount[];
  transactions: Transaction[];
  likes: Like[];
  comments: Comment[];
  notifications: NotificationType[];
  banktransfers: BankTransfer[];
};

const USER_TABLE = "users";
const CONTACT_TABLE = "contacts";
const BANK_ACCOUNT_TABLE = "bankaccounts";
const TRANSACTION_TABLE = "transactions";
const LIKE_TABLE = "likes";
const COMMENT_TABLE = "comments";
const NOTIFICATION_TABLE = "notifications";
const BANK_TRANSFER_TABLE = "banktransfers";

const databaseFile = path.join(__dirname, "../data/database.json");
const adapter = new FileSync<DbSchema>(databaseFile);

const db = low(adapter);

export const seedDatabase = () => {
  const testSeed = JSON.parse(
    fs.readFileSync(path.join(process.cwd(), "data", "database-seed.json"), "utf-8")
  );

  // seed database with test data
  db.setState(testSeed).write();
  return;
};

export const getAllUsers = () => db.get(USER_TABLE).value();

export const getAllPublicTransactions = () =>
  db.get(TRANSACTION_TABLE).filter({ privacyLevel: DefaultPrivacyLevel.public }).value();

export const getAllForEntity = (entity: keyof DbSchema) => db.get(entity).value();

export const getAllBy = (entity: keyof DbSchema, key: string, value: any) => {
  const result = db
    .get(entity)
    // @ts-ignore
    .filter({ [`${key}`]: value })
    .value();

  return result;
};

export const getBy = (entity: keyof DbSchema, key: string, value: any) => {
  const result = db
    .get(entity)
    // @ts-ignore
    .find({ [`${key}`]: value })
    .value();

  return result;
};

export const getAllByObj = (entity: keyof DbSchema, query: object) => {
  const result = db
    .get(entity)
    // @ts-ignore
    .filter(query)
    .value();

  return result;
};

// Search
export const cleanSearchQuery = (query: string) => query.replace(/[^a-zA-Z0-9]/g, "");

export const setupSearch = curry((items: object[], options: {}, query: string) => {
  const fuse = new Fuse(items, options);
  return fuse.search(query);
});

export const performSearch = (items: object[], options: {}, query: string) =>
  flow(
    cleanSearchQuery,
    setupSearch(items, options),
    map((result) => result.item)
  )(query);

export const searchUsers = (query: string) => {
  const items = getAllUsers();
  return performSearch(
    items,
    {
      keys: ["firstName", "lastName", "username", "email", "phoneNumber"],
    },
    query
  ) as User[];
};

export const removeUserFromResults = (userId: User["id"], results: User[]) =>
  remove({ id: userId }, results);

// convenience methods

// User
export const getUserBy = (key: string, value: any) => getBy(USER_TABLE, key, value);
export const getUserId = (user: User): string => user.id;
export const getUserById = (id: string) => getUserBy("id", id);
export const getUserByUsername = (username: string) => getUserBy("username", username);

export const createUser = (userDetails: Partial<User>): User => {
  const password = bcrypt.hashSync(userDetails.password!, 10);
  const user: User = {
    id: shortid(),
    uuid: v4(),
    firstName: userDetails.firstName!,
    lastName: userDetails.lastName!,
    username: userDetails.username!,
    password,
    email: userDetails.email!,
    phoneNumber: userDetails.phoneNumber!,
    balance: userDetails.balance! || 0,
    avatar: userDetails.avatar!,
    defaultPrivacyLevel: userDetails.defaultPrivacyLevel!,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  saveUser(user);
  return user;
};

const saveUser = (user: User) => {
  db.get(USER_TABLE).push(user).write();
};

export const updateUserById = (userId: string, edits: Partial<User>) => {
  const user = getUserById(userId);

  db.get(USER_TABLE).find(user).assign(edits).write();
};

// Contact
export const getContactBy = (key: string, value: any) => getBy(CONTACT_TABLE, key, value);

export const getContactsBy = (key: string, value: any) => getAllBy(CONTACT_TABLE, key, value);

export const getContactsByUsername = (username: string) =>
  flow(getUserByUsername, getUserId, getContactsByUserId)(username);

export const getContactsByUserId = (userId: string): Contact[] => getContactsBy("userId", userId);

export const createContact = (contact: Contact) => {
  db.get(CONTACT_TABLE).push(contact).write();

  // manual lookup after create
  return getContactBy("id", contact.id);
};

export const removeContactById = (contactId: string) => {
  const contact = getContactBy("id", contactId);

  db.get(CONTACT_TABLE).remove(contact).write();
};

export const createContactForUser = (userId: string, contactUserId: string) => {
  const contactId = shortid();
  const contact: Contact = {
    id: contactId,
    uuid: v4(),
    userId,
    contactUserId,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  // Write contact record to the database
  const result = createContact(contact);

  return result;
};

// Bank Account
export const getBankAccountBy = (key: string, value: any) => getBy(BANK_ACCOUNT_TABLE, key, value);

export const getBankAccountById = (id: string) => getBankAccountBy("id", id);

export const getBankAccountsBy = (key: string, value: any) =>
  getAllBy(BANK_ACCOUNT_TABLE, key, value);

export const createBankAccount = (bankaccount: BankAccount) => {
  db.get(BANK_ACCOUNT_TABLE).push(bankaccount).write();

  // manual lookup after create
  return getBankAccountBy("id", bankaccount.id);
};

export const createBankAccountForUser = (userId: string, accountDetails: Partial<BankAccount>) => {
  const accountId = shortid();
  const bankaccount: BankAccount = {
    id: accountId,
    uuid: v4(),
    userId,
    bankName: accountDetails.bankName!,
    accountNumber: accountDetails.accountNumber!,
    routingNumber: accountDetails.routingNumber!,
    isDeleted: false,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  // Write bank account record to the database
  const result = createBankAccount(bankaccount);

  return result;
};

export const removeBankAccountById = (bankAccountId: string) => {
  db.get(BANK_ACCOUNT_TABLE)
    .find({ id: bankAccountId })
    .assign({ isDeleted: true }) // soft delete
    .write();
};

// Bank Transfer
// Note: Balance transfers from/to bank accounts is a future feature,
// but some of the backend database functionality is already implemented here.

/* istanbul ignore next */
export const getBankTransferBy = (key: string, value: any) =>
  getBy(BANK_TRANSFER_TABLE, key, value);

export const getBankTransfersBy = (key: string, value: any) =>
  getAllBy(BANK_TRANSFER_TABLE, key, value);

export const getBankTransfersByUserId = (userId: string) => getBankTransfersBy("userId", userId);

/* istanbul ignore next */
export const createBankTransfer = (bankTransferDetails: BankTransferPayload) => {
  const bankTransfer: BankTransfer = {
    id: shortid(),
    uuid: v4(),
    ...bankTransferDetails,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  const savedBankTransfer = saveBankTransfer(bankTransfer);
  return savedBankTransfer;
};

/* istanbul ignore next */
const saveBankTransfer = (bankTransfer: BankTransfer): BankTransfer => {
  db.get(BANK_TRANSFER_TABLE).push(bankTransfer).write();

  // manual lookup after banktransfer created
  return getBankTransferBy("id", bankTransfer.id);
};

// Transaction

export const getTransactionBy = (key: string, value: any) => getBy(TRANSACTION_TABLE, key, value);

export const getTransactionById = (id: string) => getTransactionBy("id", id);

export const getTransactionsByObj = (query: object) => getAllByObj(TRANSACTION_TABLE, query);

export const getTransactionByIdForApi = (id: string) =>
  formatTransactionForApiResponse(getTransactionBy("id", id));

export const getTransactionsForUserForApi = (userId: string, query?: object) =>
  flow(getTransactionsForUserByObj(userId), formatTransactionsForApiResponse)(query);

export const getFullNameForUser = (userId: User["id"]) => flow(getUserById, formatFullName)(userId);

export const formatTransactionForApiResponse = (
  transaction: Transaction
): TransactionResponseItem => {
  const receiver = getUserById(transaction.receiverId);
  const sender = getUserById(transaction.senderId);

  const receiverName = getFullNameForUser(transaction.receiverId);
  const senderName = getFullNameForUser(transaction.senderId);
  const likes = getLikesByTransactionId(transaction.id);
  const comments = getCommentsByTransactionId(transaction.id);

  return {
    receiverName,
    senderName,
    receiverAvatar: receiver.avatar,
    senderAvatar: sender.avatar,
    likes,
    comments,
    ...transaction,
  };
};

export const formatTransactionsForApiResponse = (
  transactions: Transaction[]
): TransactionResponseItem[] =>
  orderBy(
    [(transaction: Transaction) => new Date(transaction.modifiedAt)],
    ["desc"],
    transactions.map((transaction) => formatTransactionForApiResponse(transaction))
  );

export const getAllTransactionsForUserByObj = curry((userId: string, query?: object) => {
  const queryWithoutFilterFields = query && getQueryWithoutFilterFields(query);

  const queryFields = queryWithoutFilterFields || query;

  const userTransactions = flatMap(getTransactionsByObj)([
    {
      receiverId: userId,
      ...queryFields,
    },
    {
      senderId: userId,
      ...queryFields,
    },
  ]);

  if (query && (hasDateQueryFields(query) || hasAmountQueryFields(query))) {
    const { dateRangeStart, dateRangeEnd } = getDateQueryFields(query);
    const { amountMin, amountMax } = getAmountQueryFields(query);

    return flow(
      transactionsWithinDateRange(dateRangeStart!, dateRangeEnd!),
      transactionsWithinAmountRange(amountMin!, amountMax!)
    )(userTransactions);
  }
  return userTransactions;
});

export const transactionsWithinAmountRange = curry(
  (amountMin: number, amountMax: number, transactions: Transaction[]) => {
    if (!amountMin || !amountMax) {
      return transactions;
    }

    return filter(
      (transaction: Transaction) => inRange(amountMin, amountMax, transaction.amount),
      transactions
    );
  }
);

export const transactionsWithinDateRange = curry(
  (dateRangeStart: string, dateRangeEnd: string, transactions: Transaction[]) => {
    if (!dateRangeStart || !dateRangeEnd) {
      return transactions;
    }

    return filter(
      (transaction: Transaction) =>
        isWithinInterval(new Date(transaction.createdAt), {
          start: new Date(dateRangeStart),
          end: new Date(dateRangeEnd),
        }),
      transactions
    );
  }
);

export const getTransactionsForUserByObj = curry((userId: string, query?: object) =>
  flow(getAllTransactionsForUserByObj(userId), uniqBy("id"))(query)
);

export const getContactIdsForUser = (userId: string): Contact["id"][] =>
  flow(getContactsByUserId, map("contactUserId"))(userId);

export const getTransactionsForUserContacts = (userId: string, query?: object) =>
  uniqBy(
    "id",
    flatMap(
      (contactId) => getTransactionsForUserForApi(contactId, query),
      getContactIdsForUser(userId)
    )
  );

export const getTransactionIds = (transactions: Transaction[]) => map("id", transactions);

export const getContactsTransactionIds = (userId: string): Transaction["id"][] =>
  flow(getTransactionsForUserContacts, getTransactionIds)(userId);

export const nonContactPublicTransactions = (userId: string): Transaction[] => {
  const contactsTransactionIds = getContactsTransactionIds(userId);
  return flow(
    getAllPublicTransactions,
    reject((transaction: Transaction) => includes(transaction.id, contactsTransactionIds))
  )();
};

export const getNonContactPublicTransactionsForApi = (userId: string) =>
  flow(nonContactPublicTransactions, formatTransactionsForApiResponse)(userId);

export const getPublicTransactionsDefaultSort = (userId: string) => ({
  contactsTransactions: getTransactionsForUserContacts(userId),
  publicTransactions: getNonContactPublicTransactionsForApi(userId),
});

export const getPublicTransactionsByQuery = (userId: string, query: TransactionQueryPayload) => {
  if (query && (hasDateQueryFields(query) || hasAmountQueryFields(query))) {
    const { dateRangeStart, dateRangeEnd } = getDateQueryFields(query);
    const { amountMin, amountMax } = getAmountQueryFields(query);

    return {
      contactsTransactions: getTransactionsForUserContacts(userId, query),
      publicTransactions: flow(
        transactionsWithinDateRange(dateRangeStart!, dateRangeEnd!),
        transactionsWithinAmountRange(amountMin!, amountMax!)
      )(getNonContactPublicTransactionsForApi(userId)),
    };
  } else {
    return {
      contactsTransactions: getTransactionsForUserContacts(userId),
      publicTransactions: getNonContactPublicTransactionsForApi(userId),
    };
  }
};

export const resetPayAppBalance = constant(0);

export const debitPayAppBalance = (user: User, transaction: Transaction) => {
  if (hasSufficientFunds(user, transaction)) {
    flow(getChargeAmount, savePayAppBalance(user))(user, transaction);
  } else {
    /* istanbul ignore next */
    flow(
      getTransferAmount(user),
      createBankTransferWithdrawal(user, transaction),
      resetPayAppBalance,
      savePayAppBalance(user)
    )(transaction);
  }
};

export const creditPayAppBalance = (user: User, transaction: Transaction) =>
  flow(getPayAppCreditedAmount, savePayAppBalance(user))(user, transaction);

/* istanbul ignore next */
export const createBankTransferWithdrawal = curry(
  (sender: User, transaction: Transaction, transferAmount: number) =>
    createBankTransfer({
      userId: sender.id,
      source: transaction.source,
      amount: transferAmount,
      transactionId: transaction.id,
      type: BankTransferType.withdrawal,
    })
);

export const savePayAppBalance = curry((sender: User, balance: number) =>
  updateUserById(get("id", sender), { balance })
);

export const createTransaction = (
  userId: User["id"],
  transactionType: "payment" | "request",
  transactionDetails: TransactionPayload
): Transaction => {
  const sender = getUserById(userId);
  const receiver = getUserById(transactionDetails.receiverId);
  const transaction: Transaction = {
    id: shortid(),
    uuid: v4(),
    source: transactionDetails.source,
    amount: transactionDetails.amount * 100,
    description: transactionDetails.description,
    receiverId: transactionDetails.receiverId,
    senderId: userId,
    privacyLevel: transactionDetails.privacyLevel || sender.defaultPrivacyLevel,
    status: TransactionStatus.pending,
    requestStatus: transactionType === "request" ? TransactionRequestStatus.pending : undefined,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  const savedTransaction = saveTransaction(transaction);

  // if payment, debit sender's balance for payment amount
  if (isPayment(transaction)) {
    debitPayAppBalance(sender, transaction);
    creditPayAppBalance(receiver, transaction);
    updateTransactionById(transaction.id, {
      status: TransactionStatus.complete,
    });
    createPaymentNotification(
      transaction.receiverId,
      transaction.id,
      PaymentNotificationStatus.received
    );
  } else {
    createPaymentNotification(
      transaction.receiverId,
      transaction.id,
      PaymentNotificationStatus.requested
    );
  }

  return savedTransaction;
};

const saveTransaction = (transaction: Transaction): Transaction => {
  db.get(TRANSACTION_TABLE).push(transaction).write();

  // manual lookup after transaction created
  return getTransactionBy("id", transaction.id);
};

export const updateTransactionById = (transactionId: string, edits: Partial<Transaction>) => {
  const transaction = getTransactionBy("id", transactionId);
  const { senderId, receiverId } = transaction;
  const sender = getUserById(senderId);
  const receiver = getUserById(receiverId);

  // if payment, debit sender's balance for payment amount
  if (isRequestTransaction(transaction)) {
    debitPayAppBalance(receiver, transaction);
    creditPayAppBalance(sender, transaction);
    edits.status = TransactionStatus.complete;

    createPaymentNotification(
      transaction.senderId,
      transaction.id,
      PaymentNotificationStatus.received
    );
  }

  db.get(TRANSACTION_TABLE).find(transaction).assign(edits).write();
};

// Likes

export const getLikeBy = (key: string, value: any): Like => getBy(LIKE_TABLE, key, value);
export const getLikesByObj = (query: object) => getAllByObj(LIKE_TABLE, query);

export const getLikeById = (id: string): Like => getLikeBy("id", id);
export const getLikesByTransactionId = (transactionId: string) => getLikesByObj({ transactionId });

export const createLike = (userId: string, transactionId: string): Like => {
  const like = {
    id: shortid(),
    uuid: v4(),
    userId,
    transactionId,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  const savedLike = saveLike(like);
  return savedLike;
};

export const createLikes = (userId: string, transactionId: string) => {
  const { senderId, receiverId } = getTransactionById(transactionId);

  const like = createLike(userId, transactionId);

  /* istanbul ignore next */
  if (userId !== senderId || userId !== receiverId) {
    createLikeNotification(senderId, transactionId, like.id);
    createLikeNotification(receiverId, transactionId, like.id);
  } else if (userId === senderId) {
    createLikeNotification(senderId, transactionId, like.id);
  } else {
    createLikeNotification(receiverId, transactionId, like.id);
  }
};

const saveLike = (like: Like): Like => {
  db.get(LIKE_TABLE).push(like).write();

  // manual lookup after like created
  return getLikeById(like.id);
};

// Comments

export const getCommentBy = (key: string, value: any): Comment => getBy(COMMENT_TABLE, key, value);
export const getCommentsByObj = (query: object) => getAllByObj(COMMENT_TABLE, query);

export const getCommentById = (id: string): Comment => getCommentBy("id", id);
export const getCommentsByTransactionId = (transactionId: string) =>
  getCommentsByObj({ transactionId });

export const createComment = (userId: string, transactionId: string, content: string): Comment => {
  const comment = {
    id: shortid(),
    uuid: v4(),
    content,
    userId,
    transactionId,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  const savedComment = saveComment(comment);
  return savedComment;
};

export const createComments = (userId: string, transactionId: string, content: string) => {
  const { senderId, receiverId } = getTransactionById(transactionId);

  const comment = createComment(userId, transactionId, content);

  /* istanbul ignore next */
  if (userId !== senderId || userId !== receiverId) {
    createCommentNotification(senderId, transactionId, comment.id);
    createCommentNotification(receiverId, transactionId, comment.id);
  } else if (userId === senderId) {
    createCommentNotification(senderId, transactionId, comment.id);
  } else {
    createCommentNotification(receiverId, transactionId, comment.id);
  }
};

const saveComment = (comment: Comment): Comment => {
  db.get(COMMENT_TABLE).push(comment).write();

  // manual lookup after comment created
  return getCommentById(comment.id);
};

// Notifications

export const getNotificationBy = (key: string, value: any): NotificationType =>
  getBy(NOTIFICATION_TABLE, key, value);

export const getNotificationsByObj = (query: object): Notification[] =>
  getAllByObj(NOTIFICATION_TABLE, query);

export const getUnreadNotificationsByUserId = (userId: string) =>
  flow(getNotificationsByObj, formatNotificationsForApiResponse)({ userId, isRead: false });

export const createPaymentNotification = (
  userId: string,
  transactionId: string,
  status: PaymentNotificationStatus
): PaymentNotification => {
  const notification: PaymentNotification = {
    id: shortid(),
    uuid: v4(),
    userId: userId,
    transactionId: transactionId,
    status,
    isRead: false,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  saveNotification(notification);
  return notification;
};

export const createLikeNotification = (
  userId: string,
  transactionId: string,
  likeId: string
): LikeNotification => {
  const notification: LikeNotification = {
    id: shortid(),
    uuid: v4(),
    userId: userId,
    transactionId: transactionId,
    likeId: likeId,
    isRead: false,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  saveNotification(notification);
  return notification;
};

export const createCommentNotification = (
  userId: string,
  transactionId: string,
  commentId: string
): CommentNotification => {
  const notification: CommentNotification = {
    id: shortid(),
    uuid: v4(),
    userId: userId,
    transactionId: transactionId,
    commentId: commentId,
    isRead: false,
    createdAt: new Date(),
    modifiedAt: new Date(),
  };

  saveNotification(notification);
  return notification;
};

const saveNotification = (notification: NotificationType) => {
  db.get(NOTIFICATION_TABLE).push(notification).write();
};

export const createNotifications = (userId: string, notifications: NotificationPayloadType[]) =>
  notifications.flatMap((item: NotificationPayloadType) => {
    if ("status" in item && item.type === NotificationsType.payment) {
      return createPaymentNotification(userId, item.transactionId, item.status);
    } else if ("likeId" in item && item.type === NotificationsType.like) {
      return createLikeNotification(userId, item.transactionId, item.likeId);
    } else {
      /* istanbul ignore next */
      if ("commentId" in item) {
        return createCommentNotification(userId, item.transactionId, item.commentId);
      }
    }
  });

export const updateNotificationById = (
  userId: string,
  notificationId: string,
  edits: Partial<NotificationType>
) => {
  const notification = getNotificationBy("id", notificationId);

  db.get(NOTIFICATION_TABLE).find(notification).assign(edits).write();
};

export const formatNotificationForApiResponse = (
  notification: NotificationType
): NotificationResponseItem => {
  let userFullName = getFullNameForUser(notification.userId);
  const transaction = getTransactionById(notification.transactionId);

  if (isRequestTransaction(transaction)) {
    userFullName = getFullNameForUser(transaction.senderId);
  }

  if (isLikeNotification(notification)) {
    const like = getLikeById(notification.likeId);
    userFullName = getFullNameForUser(like.userId);
  }

  if (isCommentNotification(notification)) {
    const comment = getCommentById(notification.commentId);
    userFullName = getFullNameForUser(comment.userId);
  }

  return {
    userFullName,
    ...notification,
  };
};

export const formatNotificationsForApiResponse = (
  notifications: NotificationResponseItem[]
): NotificationResponseItem[] =>
  orderBy(
    [(notification: NotificationResponseItem) => new Date(notification.modifiedAt)],
    ["desc"],
    notifications.map((notification) => formatNotificationForApiResponse(notification))
  );

// dev/test private methods
/* istanbul ignore next */
export const getRandomUser = () => {
  const users = getAllUsers();
  return sample(users)!;
};

/* istanbul ignore next */
export const getAllContacts = () => db.get(CONTACT_TABLE).value();

/* istanbul ignore next */
export const getAllTransactions = () => db.get(TRANSACTION_TABLE).value();

/* istanbul ignore */
export const getBankAccountsByUserId = (userId: string) => getBankAccountsBy("userId", userId);

/* istanbul ignore next */
export const getNotificationById = (id: string): NotificationType => getNotificationBy("id", id);

/* istanbul ignore next */
export const getNotificationsByUserId = (userId: string) => getNotificationsByObj({ userId });

/* istanbul ignore next */
export const getBankTransferByTransactionId = (transactionId: string) =>
  getBankTransferBy("transactionId", transactionId);

/* istanbul ignore next */
export const getTransactionsBy = (key: string, value: string) =>
  getAllBy(TRANSACTION_TABLE, key, value);

/* istanbul ignore next */
export const getTransactionsByUserId = (userId: string) => getTransactionsBy("receiverId", userId);

export default db;



================================================
FILE: cypress-realworld-app/backend/helpers.ts
================================================
import { Request, Response, NextFunction } from "express";
import { validationResult } from "express-validator";
export const ensureAuthenticated = (req: Request, res: Response, next: NextFunction) => {
  if (req.isAuthenticated()) {
    return next();
  }
  /* istanbul ignore next */
  res.status(401).send({
    error: "Unauthorized",
  });
};

export const validateMiddleware = (validations: any[]) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    await Promise.all(validations.map((validation: any) => validation.run(req)));

    const errors = validationResult(req);
    if (errors.isEmpty()) {
      return next();
    }

    res.status(422).json({ errors: errors.array() });
  };
};



================================================
FILE: cypress-realworld-app/backend/like-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";
import { getLikesByTransactionId, createLikes } from "./database";
import { ensureAuthenticated, validateMiddleware } from "./helpers";
import { shortIdValidation } from "./validators";
const router = express.Router();

// Routes

//GET /likes/:transactionId
router.get(
  "/:transactionId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("transactionId")]),
  (req, res) => {
    const { transactionId } = req.params;
    const likes = getLikesByTransactionId(transactionId);

    res.status(200);
    res.json({ likes });
  }
);

//POST /likes/:transactionId
router.post(
  "/:transactionId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("transactionId")]),
  (req, res) => {
    const { transactionId } = req.params;
    /* istanbul ignore next */
    createLikes(req.user?.id!, transactionId);

    res.sendStatus(200);
  }
);

export default router;



================================================
FILE: cypress-realworld-app/backend/notification-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";
import {
  createNotifications,
  updateNotificationById,
  getUnreadNotificationsByUserId,
} from "./database";
import { ensureAuthenticated, validateMiddleware } from "./helpers";
import {
  isNotificationsBodyValidator,
  shortIdValidation,
  isNotificationPatchValidator,
} from "./validators";
const router = express.Router();

// Routes

//GET /notifications/
router.get("/", ensureAuthenticated, (req, res) => {
  /* istanbul ignore next */
  const notifications = getUnreadNotificationsByUserId(req.user?.id!);

  res.status(200);
  res.json({ results: notifications });
});

//POST /notifications/bulk
router.post(
  "/bulk",
  ensureAuthenticated,
  validateMiddleware([...isNotificationsBodyValidator]),
  (req, res) => {
    const { items } = req.body;
    /* istanbul ignore next */
    const notifications = createNotifications(req.user?.id!, items);

    res.status(200);
    // @ts-ignore
    res.json({ results: notifications });
  }
);

//PATCH /notifications/:notificationId - scoped-user
router.patch(
  "/:notificationId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("notificationId"), ...isNotificationPatchValidator]),
  (req, res) => {
    const { notificationId } = req.params;
    /* istanbul ignore next */
    updateNotificationById(req.user?.id!, notificationId, req.body);

    res.sendStatus(204);
  }
);

export default router;



================================================
FILE: cypress-realworld-app/backend/testdata-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";
import { getAllForEntity, seedDatabase } from "./database";
import { validateMiddleware } from "./helpers";
import { isValidEntityValidator } from "./validators";
import { DbSchema } from "../src/models/db-schema";
const router = express.Router();

// Routes

//POST /testData/seed
router.post("/seed", (req, res) => {
  seedDatabase();
  res.sendStatus(200);
});

//GET /testData/:entity
router.get("/:entity", validateMiddleware([...isValidEntityValidator]), (req, res) => {
  const { entity } = req.params;
  const results = getAllForEntity(entity as keyof DbSchema);

  res.status(200);
  res.json({ results });
});

export default router;



================================================
FILE: cypress-realworld-app/backend/transaction-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";
import { remove, isEmpty, slice, concat } from "lodash/fp";
import {
  getTransactionsForUserContacts,
  createTransaction,
  updateTransactionById,
  getPublicTransactionsDefaultSort,
  getTransactionByIdForApi,
  getTransactionsForUserForApi,
  getPublicTransactionsByQuery,
} from "./database";
import { ensureAuthenticated, validateMiddleware } from "./helpers";
import {
  sanitizeTransactionStatus,
  sanitizeRequestStatus,
  isTransactionQSValidator,
  isTransactionPayloadValidator,
  shortIdValidation,
  isTransactionPatchValidator,
  isTransactionPublicQSValidator,
} from "./validators";
import { getPaginatedItems } from "../src/utils/transactionUtils";
const router = express.Router();

// Routes

//GET /transactions - scoped user, auth-required
router.get(
  "/",
  ensureAuthenticated,
  validateMiddleware([
    sanitizeTransactionStatus,
    sanitizeRequestStatus,
    ...isTransactionQSValidator,
  ]),
  (req, res) => {
    /* istanbul ignore next */
    const transactions = getTransactionsForUserForApi(req.user?.id!, req.query);

    const { totalPages, data: paginatedItems } = getPaginatedItems(
      req.query.page,
      req.query.limit,
      transactions
    );

    res.status(200);
    res.json({
      pageData: {
        page: res.locals.paginate.page,
        limit: res.locals.paginate.limit,
        hasNextPages: res.locals.paginate.hasNextPages(totalPages),
        totalPages,
      },
      results: paginatedItems,
    });
  }
);

//GET /transactions/contacts - scoped user, auth-required
router.get(
  "/contacts",
  ensureAuthenticated,
  validateMiddleware([
    sanitizeTransactionStatus,
    sanitizeRequestStatus,
    ...isTransactionQSValidator,
  ]),
  (req, res) => {
    /* istanbul ignore next */
    const transactions = getTransactionsForUserContacts(req.user?.id!, req.query);

    const { totalPages, data: paginatedItems } = getPaginatedItems(
      req.query.page,
      req.query.limit,
      transactions
    );

    res.status(200);
    res.json({
      pageData: {
        page: res.locals.paginate.page,
        limit: res.locals.paginate.limit,
        hasNextPages: res.locals.paginate.hasNextPages(totalPages),
        totalPages,
      },
      results: paginatedItems,
    });
  }
);

//GET /transactions/public - auth-required
router.get(
  "/public",
  ensureAuthenticated,
  validateMiddleware(isTransactionPublicQSValidator),
  (req, res) => {
    const isFirstPage = req.query.page === 1;

    /* istanbul ignore next */
    let transactions = !isEmpty(req.query)
      ? getPublicTransactionsByQuery(req.user?.id!, req.query)
      : /* istanbul ignore next */
        getPublicTransactionsDefaultSort(req.user?.id!);

    const { contactsTransactions, publicTransactions } = transactions;

    let publicTransactionsWithContacts;

    if (isFirstPage) {
      const firstFiveContacts = slice(0, 5, contactsTransactions);

      publicTransactionsWithContacts = concat(firstFiveContacts, publicTransactions);
    }

    const { totalPages, data: paginatedItems } = getPaginatedItems(
      req.query.page,
      req.query.limit,
      isFirstPage ? publicTransactionsWithContacts : publicTransactions
    );

    res.status(200);
    res.json({
      pageData: {
        page: res.locals.paginate.page,
        limit: res.locals.paginate.limit,
        hasNextPages: res.locals.paginate.hasNextPages(totalPages),
        totalPages,
      },
      results: paginatedItems,
    });
  }
);

//POST /transactions - scoped-user
router.post(
  "/",
  ensureAuthenticated,
  validateMiddleware(isTransactionPayloadValidator),
  (req, res) => {
    const transactionPayload = req.body;
    const transactionType = transactionPayload.transactionType;

    remove("transactionType", transactionPayload);

    /* istanbul ignore next */
    const transaction = createTransaction(req.user?.id!, transactionType, transactionPayload);

    res.status(200);
    res.json({ transaction });
  }
);

//GET /transactions/:transactionId - scoped-user
router.get(
  "/:transactionId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("transactionId")]),
  (req, res) => {
    const { transactionId } = req.params;

    const transaction = getTransactionByIdForApi(transactionId);

    res.status(200);
    res.json({ transaction });
  }
);

//PATCH /transactions/:transactionId - scoped-user
router.patch(
  "/:transactionId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("transactionId"), ...isTransactionPatchValidator]),
  (req, res) => {
    const { transactionId } = req.params;

    /* istanbul ignore next */
    updateTransactionById(transactionId, req.body);

    res.sendStatus(204);
  }
);

export default router;



================================================
FILE: cypress-realworld-app/backend/types.ts
================================================
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { User as IUser } from "../src/models/user";

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace Express {
    interface User extends IUser {}
  }
}



================================================
FILE: cypress-realworld-app/backend/user-routes.ts
================================================
///<reference path="types.ts" />

import express from "express";
import { isEqual, pick } from "lodash/fp";

import {
  getAllUsers,
  createUser,
  updateUserById,
  getUserById,
  getUserByUsername,
  searchUsers,
  removeUserFromResults,
} from "./database";
import { User } from "../src/models/user";
import { ensureAuthenticated, validateMiddleware } from "./helpers";
import {
  shortIdValidation,
  searchValidation,
  userFieldsValidator,
  isUserValidator,
} from "./validators";
const router = express.Router();

// Routes
router.get("/", ensureAuthenticated, (req, res) => {
  /* istanbul ignore next */
  const users = removeUserFromResults(req.user?.id!, getAllUsers());
  res.status(200).json({ results: users });
});

router.get("/search", ensureAuthenticated, validateMiddleware([searchValidation]), (req, res) => {
  const { q } = req.query;

  /* istanbul ignore next */
  const users = removeUserFromResults(req.user?.id!, searchUsers(q));

  res.status(200).json({ results: users });
});

router.post("/", userFieldsValidator, validateMiddleware(isUserValidator), (req, res) => {
  const userDetails: User = req.body;

  const user = createUser(userDetails);

  res.status(201);
  res.json({ user: user });
});

router.get(
  "/:userId",
  ensureAuthenticated,
  validateMiddleware([shortIdValidation("userId")]),
  (req, res) => {
    const { userId } = req.params;

    // Permission: account owner
    /* istanbul ignore next */
    if (!isEqual(userId, req.user?.id)) {
      return res.status(401).send({
        error: "Unauthorized",
      });
    }

    const user = getUserById(userId);

    res.status(200);
    res.json({ user });
  }
);

router.get("/profile/:username", (req, res) => {
  const { username } = req.params;

  const user = pick(["firstName", "lastName", "avatar"], getUserByUsername(username));

  res.status(200);
  res.json({ user });
});

router.patch(
  "/:userId",
  ensureAuthenticated,
  userFieldsValidator,
  validateMiddleware([shortIdValidation("userId"), ...isUserValidator]),
  (req, res) => {
    const { userId } = req.params;

    const edits: User = req.body;

    updateUserById(userId, edits);

    res.sendStatus(204);
  }
);

export default router;



================================================
FILE: cypress-realworld-app/backend/validators.ts
================================================
import { body, check, oneOf, query, sanitizeQuery } from "express-validator";
import { isValid } from "shortid";
import {
  TransactionStatus,
  TransactionRequestStatus,
  DefaultPrivacyLevel,
  NotificationsType,
} from "../src/models";
import { includes } from "lodash/fp";

const TransactionStatusValues = Object.values(TransactionStatus);
const RequestStatusValues = Object.values(TransactionRequestStatus);
const DefaultPrivacyLevelValues = Object.values(DefaultPrivacyLevel);
const NotificationsTypeValues = Object.values(NotificationsType);

// Validators

const isShortId = (value: string) => isValid(value);

export const shortIdValidation = (key: string) => check(key).custom(isShortId);

export const searchValidation = query("q").exists();

export const userFieldsValidator = oneOf([
  check("firstName").exists(),
  check("lastName").exists(),
  check("password").exists(),
  check("balance").exists(),
  check("avatar").exists(),
  check("defaultPrivacyLevel").exists(),
]);

export const isBankAccountValidator = [
  body("bankName").isString().trim(),
  body("accountNumber").isString().trim(),
  body("routingNumber").isString().trim(),
];

export const isUserValidator = [
  check("firstName").optional({ checkFalsy: true }).isString().trim(),
  check("lastName").optional({ checkFalsy: true }).isString().trim(),
  check("username").optional({ checkFalsy: true }).isString().trim(),
  check("password").optional({ checkFalsy: true }).isString().trim(),
  check("email").optional({ checkFalsy: true }).isString().trim(),
  check("phoneNumber").optional({ checkFalsy: true }).isString().trim(),
  check("balance").optional({ checkFalsy: true }).isNumeric().trim(),
  check("avatar").optional({ checkFalsy: true }).isURL().trim(),
  check("defaultPrivacyLevel")
    .optional({ checkFalsy: true })
    .isIn(["public", "private", "contacts"]),
];

export const sanitizeTransactionStatus = sanitizeQuery("status").customSanitizer((value) => {
  /* istanbul ignore if*/
  if (includes(value, TransactionStatusValues)) {
    return value;
  }
  return;
});

// default request status to undefined if not provided
export const sanitizeRequestStatus = sanitizeQuery("requestStatus").customSanitizer((value) => {
  /* istanbul ignore if*/
  if (includes(value, RequestStatusValues)) {
    return value;
  }
  return;
});

export const isTransactionQSValidator = [
  query("status").isIn(TransactionStatusValues).optional().trim(),
  query("requestStatus").optional({ checkFalsy: true }).isIn(RequestStatusValues).trim(),
  query("receiverId").optional({ checkFalsy: true }).isString().trim(),
  query("senderId").optional({ checkFalsy: true }).isString().trim(),
  query("rangeStartTs").optional({ checkFalsy: true }).isString().trim(),
  query("rangeEndTs").optional({ checkFalsy: true }).isString().trim(),
  query("amountMax").optional({ checkFalsy: true }).isNumeric().trim(),
  query("amountMin").optional({ checkFalsy: true }).isNumeric().trim(),
];

export const isTransactionPayloadValidator = [
  body("transactionType").isIn(["payment", "request"]).trim(),
  body("privacyLevel").optional().isIn(DefaultPrivacyLevelValues).trim(),
  body("source").optional().isString().trim(),
  body("receiverId").isString().trim(),
  body("description").isString().trim(),
  body("amount").isNumeric().trim().toInt(),
];

export const isTransactionPatchValidator = [body("requestStatus").isIn(RequestStatusValues)];

export const isTransactionPublicQSValidator = [
  query("order").optional({ checkFalsy: true }).isIn(["default"]),
];

export const isCommentValidator = body("content").isString().trim();

export const isNotificationsBodyValidator = [
  body("items.*.type").isIn(NotificationsTypeValues).trim(),
  body("items.*.transactionId").custom(isShortId),
];

export const isNotificationPatchValidator = [body("isRead").isBoolean()];

export const isValidEntityValidator = [
  check("entity")
    .isIn([
      "users",
      "contacts",
      "bankaccounts",
      "notifications",
      "transactions",
      "likes",
      "comments",
      "banktransfers",
    ])
    .trim(),
];



================================================
FILE: cypress-realworld-app/cypress/global.d.ts
================================================
/// <reference types="cypress" />

declare namespace Cypress {
  import { authService } from "../src/machines/authMachine";
  import { createTransactionService } from "../src/machines/createTransactionMachine";
  import { publicTransactionService } from "../src/machines/publicTransactionsMachine";
  import { contactsTransactionService } from "../src/machines/contactsTransactionsMachine";
  import { personalTransactionService } from "../src/machines/personalTransactionsMachine";
  import {
    User,
    BankAccount,
    Like,
    Comment,
    Transaction,
    BankTransfer,
    Contact,
  } from "../src/models";

  interface CustomWindow extends Window {
    authService: typeof authService;
    createTransactionService: typeof createTransactionService;
    publicTransactionService: typeof publicTransactionService;
    contactTransactionService: typeof contactsTransactionService;
    personalTransactionService: typeof personalTransactionService;
  }

  type dbQueryArg = {
    entity: string;
    query: object | [object];
  };

  interface Chainable {
    /**
     *  Window object with additional properties used during test.
     */
    window(options?: Partial<Loggable & Timeoutable>): Chainable<CustomWindow>;

    getBySel(dataTestAttribute: string, args?: any): Chainable<Element>;
    getBySelLike(dataTestPrefixAttribute: string, args?: any): Chainable<Element>;

    /**
     *  Cypress task for directly querying to the database within tests
     */
    task(
      event: "filter:database",
      arg: dbQueryArg,
      options?: Partial<Loggable & Timeoutable>
    ): Chainable<any[]>;

    /**
     *  Cypress task for directly querying to the database within tests
     */
    task(
      event: "find:database",
      arg?: any,
      options?: Partial<Loggable & Timeoutable>
    ): Chainable<any>;

    /**
     * Find a single entity via database query
     */
    database(operation: "find", entity: string, query?: object, log?: boolean): Chainable<any>;

    /**
     * Filter for data entities via database query
     */
    database(operation: "filter", entity: string, query?: object, log?: boolean): Chainable<any[]>;

    /**
     * Fetch React component instance associated with received element subject
     */
    reactComponent(): Chainable<any>;

    /**
     * Select data range within date range picker component
     */
    pickDateRange(startDate: Date, endDate: Date): Chainable<void>;

    /**
     * Select transaction amount range
     */
    setTransactionAmountRange(min: number, max: number): Chainable<any>;

    /**
     * Paginate to the next page in transaction infinite-scroll pagination view
     */
    nextTransactionFeedPage(service: string, page: number): Chainable<any>;

    /**
     * Logs-in user by using UI
     */
    login(username: string, password: string, rememberUser?: boolean): void;

    /**
     * Logs-in user by using API request
     */
    loginByApi(username: string, password?: string): Chainable<Response>;

    /**
     * Logs in bypassing UI by triggering XState login event
     */
    loginByXstate(username: string, password?: string): Chainable<any>;

    /**
     * Logs out via bypassing UI by triggering XState logout event
     */
    logoutByXstate(): Chainable<void>;

    /**
     * Switch current user by logging out current user and logging as user with specified username
     */
    switchUser(username: string): Chainable<any>;

    /**
     * Create Transaction via bypassing UI and using XState createTransactionService
     */
    createTransaction(payload): Chainable<any>;
  }
}



================================================
FILE: cypress-realworld-app/cypress/tsconfig.json
================================================
{
  "extends": "../tsconfig.json",
  "include": ["./**/*.ts"],
  "exclude": [],
  "compilerOptions": {
    "types": ["cypress", "@percy/cypress"],
    "lib": ["es2015", "dom"],
    "isolatedModules": false,
    "allowJs": true,
    "noEmit": true
  }
}



================================================
FILE: cypress-realworld-app/cypress/fixtures/public-transactions.json
================================================
{
  "pageData": {
    "hasNextPages": false,
    "limit": 10,
    "page": 1,
    "totalPages": 1
  },
  "results": [
    {
      "amount": 8647,
      "balanceAtCompletion": 8958,
      "createdAt": "2019-12-10T21:38:16.311Z",
      "description": "Payment: db4uxOm7d to IMbeyzHTj9",
      "id": "si_aNEMbyCA",
      "modifiedAt": "2020-05-06T08:15:48.263Z",
      "privacyLevel": "private",
      "receiverId": "IMbeyzHTj9",
      "requestResolvedAt": "2020-06-09T19:01:15.675Z",
      "requestStatus": "",
      "senderId": "db4uxOm7d",
      "source": "GYDJUNEaOK7",
      "status": "complete",
      "uuid": "41754166-ea5b-448a-9a8a-374ce387c714",
      "receiverName": "Kevin",
      "senderName": "Amir",
      "likes": [],
      "comments": []
    },
    {
      "amount": 12724,
      "balanceAtCompletion": 45008,
      "createdAt": "2020-04-20T15:12:01.340Z",
      "description": "Request: IMbeyzHTj9 to db4uxOm7d",
      "id": "k5NjJY43WPG",
      "modifiedAt": "2020-05-06T02:36:04.844Z",
      "privacyLevel": "contacts",
      "receiverId": "IMbeyzHTj9",
      "requestResolvedAt": "2020-11-22T00:37:01.540Z",
      "requestStatus": "accepted",
      "senderId": "db4uxOm7d",
      "source": "GYDJUNEaOK7",
      "status": "complete",
      "uuid": "5cdc1625-c937-4ac5-a6ac-eb5c55e93576",
      "receiverName": "Kevin",
      "senderName": "Amir",
      "likes": [],
      "comments": []
    },
    {
      "amount": 17183,
      "balanceAtCompletion": 35847,
      "createdAt": "2020-04-19T13:29:13.910Z",
      "description": "Request: IMbeyzHTj9 to db4uxOm7d",
      "id": "C8f1XzufOzM",
      "modifiedAt": "2020-05-06T13:25:01.255Z",
      "privacyLevel": "private",
      "receiverId": "IMbeyzHTj9",
      "requestResolvedAt": "",
      "requestStatus": "pending",
      "senderId": "db4uxOm7d",
      "source": "GYDJUNEaOK7",
      "status": "pending",
      "uuid": "da9bcbd6-df80-4499-87ba-9a29927ea0c7",
      "receiverName": "Kevin",
      "senderName": "Amir",
      "likes": [],
      "comments": []
    }
  ]
}



================================================
FILE: cypress-realworld-app/cypress/plugins/index.ts
================================================
import _ from "lodash";
import axios from "axios";
import dotenv from "dotenv";
import Promise from "bluebird";
import { percyHealthCheck } from "@percy/cypress/task";
import codeCoverageTask from "@cypress/code-coverage/task";

dotenv.config();

export default (on, config) => {
  config.env.defaultPassword = process.env.SEED_DEFAULT_USER_PASSWORD;
  config.env.paginationPageSize = process.env.PAGINATION_PAGE_SIZE;

  const testDataApiEndpoint = `${config.env.apiUrl}/testData`;

  const queryDatabase = ({ entity, query }, callback) => {
    const fetchData = async (attrs) => {
      const { data } = await axios.get(`${testDataApiEndpoint}/${entity}`);
      return callback(data, attrs);
    };

    return Array.isArray(query) ? Promise.map(query, fetchData) : fetchData(query);
  };

  on("task", {
    percyHealthCheck,
    async "db:seed"() {
      // seed database with test data
      const { data } = await axios.post(`${testDataApiEndpoint}/seed`);
      return data;
    },

    // fetch test data from a database (MySQL, PostgreSQL, etc...)
    "filter:database"(queryPayload) {
      return queryDatabase(queryPayload, (data, attrs) => _.filter(data.results, attrs));
    },
    "find:database"(queryPayload) {
      return queryDatabase(queryPayload, (data, attrs) => _.find(data.results, attrs));
    },
  });

  codeCoverageTask(on, config);
  return config;
};



================================================
FILE: cypress-realworld-app/cypress/support/commands.ts
================================================
// @ts-check
///<reference path="../global.d.ts" />

import { pick } from "lodash/fp";
import { format as formatDate } from "date-fns";
import { isMobile } from "./utils";

Cypress.Commands.add("getBySel", (selector, ...args) => {
  return cy.get(`[data-test=${selector}]`, ...args);
});

Cypress.Commands.add("getBySelLike", (selector, ...args) => {
  return cy.get(`[data-test*=${selector}]`, ...args);
});

Cypress.Commands.add("login", (username, password, rememberUser = false) => {
  const signinPath = "/signin";
  const log = Cypress.log({
    name: "login",
    displayName: "LOGIN",
    message: [`ðŸ” Authenticating | ${username}`],
    // @ts-ignore
    autoEnd: false,
  });

  cy.server();
  cy.route("POST", "/login").as("loginUser");
  cy.route("GET", "checkAuth").as("getUserProfile");

  cy.location("pathname", { log: false }).then((currentPath) => {
    if (currentPath !== signinPath) {
      cy.visit(signinPath);
    }
  });

  log.snapshot("before");

  cy.getBySel("signin-username").type(username);
  cy.getBySel("signin-password").type(password);

  if (rememberUser) {
    cy.getBySel("signin-remember-me").find("input").check();
  }

  cy.getBySel("signin-submit").click();
  cy.wait("@loginUser").then((loginUser: any) => {
    log.set({
      consoleProps() {
        return {
          username,
          password,
          rememberUser,
          userId: loginUser.response.body.user?.id,
        };
      },
    });

    log.snapshot("after");
    log.end();
  });
});

Cypress.Commands.add("loginByApi", (username, password = Cypress.env("defaultPassword")) => {
  return cy.request("POST", `${Cypress.env("apiUrl")}/login`, {
    username,
    password,
  });
});

Cypress.Commands.add("reactComponent", { prevSubject: "element" }, ($el) => {
  if ($el.length !== 1) {
    throw new Error(`cy.component() requires element of length 1 but got ${$el.length}`);
  }
  const key = Object.keys($el.get(0)).find((key) => key.startsWith("__reactInternalInstance$"));

  // @ts-ignore
  const domFiber = $el.prop(key);

  Cypress.log({
    name: "component",
    consoleProps() {
      return {
        component: domFiber,
      };
    },
  });

  return domFiber.return;
});

Cypress.Commands.add("setTransactionAmountRange", (min, max) => {
  cy.getBySel("transaction-list-filter-amount-range-button")
    .scrollIntoView()
    .click({ force: true });

  return cy
    .getBySelLike("filter-amount-range-slider")
    .reactComponent()
    .its("memoizedProps")
    .invoke("onChange", null, [min / 10, max / 10]);
});

Cypress.Commands.add("loginByXstate", (username, password = Cypress.env("defaultPassword")) => {
  const log = Cypress.log({
    name: "loginbyxstate",
    displayName: "LOGIN BY XSTATE",
    message: [`ðŸ” Authenticating | ${username}`],
    // @ts-ignore
    autoEnd: false,
  });

  cy.server();
  cy.route("POST", "/login").as("loginUser");
  cy.route("GET", "/checkAuth").as("getUserProfile");
  cy.visit("/signin", { log: false }).then(() => {
    log.snapshot("before");
  });

  cy.window({ log: false }).then((win) => win.authService.send("LOGIN", { username, password }));

  return cy.wait("@loginUser").then((loginUser) => {
    log.set({
      consoleProps() {
        return {
          username,
          password,
          // @ts-ignore
          userId: loginUser.response.body.user.id,
        };
      },
    });

    log.snapshot("after");
    log.end();
  });
});

Cypress.Commands.add("logoutByXstate", () => {
  cy.server();
  cy.route("POST", "/logout").as("logoutUser");

  const log = Cypress.log({
    name: "logoutByXstate",
    displayName: "LOGOUT BY XSTATE",
    message: [`ðŸ”’ Logging out current user`],
    // @ts-ignore
    autoEnd: false,
  });

  cy.window({ log: false }).then((win) => {
    log.snapshot("before");
    win.authService.send("LOGOUT");
  });

  return cy.wait("@logoutUser").then(() => {
    log.snapshot("after");
    log.end();
  });
});

Cypress.Commands.add("switchUser", (username) => {
  cy.logoutByXstate();
  return cy.loginByXstate(username).then(() => {
    if (isMobile()) {
      cy.getBySel("sidenav-toggle").click();
      cy.getBySel("sidenav-username").contains(username);
      cy.getBySel("sidenav-toggle").click({ force: true });
    } else {
      cy.getBySel("sidenav-username").contains(username);
    }
    cy.getBySel("list-skeleton").should("not.be.visible");
    cy.getBySelLike("transaction-item").should("have.length.greaterThan", 1);
    cy.percySnapshot(`Switch to User ${username}`);
  });
});

Cypress.Commands.add("createTransaction", (payload) => {
  const log = Cypress.log({
    name: "createTransaction",
    displayName: "CREATE TRANSACTION",
    message: [`ðŸ’¸ (${payload.transactionType}): ${payload.sender.id} <> ${payload.receiver.id}`],
    // @ts-ignore
    autoEnd: false,
    consoleProps() {
      return payload;
    },
  });

  return cy
    .window({ log: false })
    .then((win) => {
      log.snapshot("before");
      win.createTransactionService.send("SET_USERS", payload);

      const createPayload = pick(["amount", "description", "transactionType"], payload);

      return win.createTransactionService.send("CREATE", {
        ...createPayload,
        senderId: payload.sender.id,
        receiverId: payload.receiver.id,
      });
    })
    .then(() => {
      log.snapshot("after");
      log.end();
    });
});

Cypress.Commands.add("nextTransactionFeedPage", (service, page) => {
  const log = Cypress.log({
    name: "nextTransactionFeedPage",
    displayName: "NEXT TRANSACTION FEED PAGE",
    message: [`ðŸ“ƒ Fetching page ${page} with ${service}`],
    // @ts-ignore
    autoEnd: false,
    consoleProps() {
      return {
        service,
        page,
      };
    },
  });

  return cy
    .window({ log: false })
    .then((win) => {
      log.snapshot("before");
      // @ts-ignore
      return win[service].send("FETCH", { page });
    })
    .then(() => {
      log.snapshot("after");
      log.end();
    });
});

Cypress.Commands.add("pickDateRange", (startDate, endDate) => {
  const log = Cypress.log({
    name: "pickDateRange",
    displayName: "PICK DATE RANGE",
    message: [`ðŸ—“ ${startDate.toDateString()} to ${endDate.toDateString()}`],
    // @ts-ignore
    autoEnd: false,
    consoleProps() {
      return {
        startDate,
        endDate,
      };
    },
  });

  const selectDate = (date: number) => {
    return cy.get(`[data-date='${formatDate(date, "yyyy-MM-dd")}']`).click({ force: true });
  };

  // Focus initial viewable date picker range around target start date
  // @ts-ignore: Cypress expects wrapped variable to be a jQuery type
  cy.wrap(startDate.getTime()).then((now) => {
    log.snapshot("before");
    // @ts-ignore
    cy.clock(now, ["Date"]);
  });

  // Open date range picker
  cy.getBySelLike("filter-date-range-button").click({ force: true });
  cy.get(".Cal__Header__root").should("be.visible");

  // Select date range
  selectDate(startDate);
  selectDate(endDate).then(() => {
    log.snapshot("after");
    log.end();
  });

  cy.get(".Cal__Header__root").should("not.be.visible");
});

Cypress.Commands.add("database", (operation, entity, query, logTask = false) => {
  const params = {
    entity,
    query,
  };

  const log = Cypress.log({
    name: "database",
    displayName: "DATABASE",
    message: [`ðŸ”Ž ${operation}ing within ${entity} data`],
    // @ts-ignore
    autoEnd: false,
    consoleProps() {
      return params;
    },
  });

  return cy.task(`${operation}:database`, params, { log: logTask }).then((data) => {
    log.snapshot();
    log.end();
    return data;
  });
});



================================================
FILE: cypress-realworld-app/cypress/support/index.ts
================================================
// @ts-check
import "@cypress/code-coverage/support";
import "@percy/cypress";
import "./commands";



================================================
FILE: cypress-realworld-app/cypress/support/utils.ts
================================================
export const isMobile = () => {
  return Cypress.config("viewportWidth") < Cypress.env("mobileViewportWidthBreakpoint");
};



================================================
FILE: cypress-realworld-app/cypress/tests/ui/auth.spec.ts
================================================
ï»¿


================================================
FILE: cypress-realworld-app/cypress/tests/ui/bankaccounts.spec.ts
================================================
[Empty file]


================================================
FILE: cypress-realworld-app/cypress/tests/ui/new-transaction.spec.ts
================================================
[Empty file]


================================================
FILE: cypress-realworld-app/cypress/tests/ui/notifications.spec.ts
================================================
[Empty file]


================================================
FILE: cypress-realworld-app/cypress/tests/ui/transaction-feeds.spec.ts
================================================
[Empty file]


================================================
FILE: cypress-realworld-app/cypress/tests/ui/transaction-view.spec.ts
================================================
[Empty file]


================================================
FILE: cypress-realworld-app/cypress/tests/ui/user-settings.spec.ts
================================================
[Empty file]


================================================
FILE: cypress-realworld-app/data/empty-seed.json
================================================
{
  "users": [],
  "contacts": [],
  "bankaccounts": [],
  "transactions": [],
  "likes": [],
  "comments": [],
  "notifications": [],
  "banktransfers": []
}



================================================
FILE: cypress-realworld-app/public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Web site created using create-react-app" />
    <link rel="apple-touch-icon" href="logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>



================================================
FILE: cypress-realworld-app/public/manifest.json
================================================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}



================================================
FILE: cypress-realworld-app/public/robots.txt
================================================
# https://www.robotstxt.org/robotstxt.html
User-agent: *



================================================
FILE: cypress-realworld-app/scripts/generateSeedData.ts
================================================
import path from "path";
import fs from "fs";
import { buildDatabase } from "./seedDataUtils";
import { TDatabase } from "../backend/database";
const testSeed: TDatabase = buildDatabase();

const fileData = JSON.stringify(testSeed, null, 2);

fs.writeFile(path.join(process.cwd(), "data", "database-seed.json"), fileData, (err) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log("test seed generated");
});



================================================
FILE: cypress-realworld-app/scripts/seedDataUtils.ts
================================================
/* eslint-disable import/first */
require("dotenv").config();

import shortid from "shortid";
import faker from "faker";
import bcrypt from "bcryptjs";
import {
  map,
  flattenDeep,
  times,
  concat,
  sample,
  reject,
  uniqBy,
  flow,
  get,
  curry,
  filter,
  isEqual,
  flattenDepth,
  negate,
  find,
  intersectionWith,
  compact,
  differenceBy,
  sampleSize,
} from "lodash/fp";
import {
  BankAccount,
  User,
  DefaultPrivacyLevel,
  Like,
  Comment,
  PaymentNotification,
  NotificationType,
  LikeNotification,
  CommentNotification,
  Transaction,
  TransactionStatus,
  TransactionRequestStatus,
  TransactionScenario,
  FakeTransaction,
  Contact,
  BankTransferType,
  BankTransfer,
  PaymentNotificationStatus,
} from "../src/models";
import { getFakeAmount } from "../src/utils/transactionUtils";

export const userbaseSize = +process.env.SEED_USERBASE_SIZE!;
export const contactsPerUser = +process.env.SEED_CONTACTS_PER_USER!;
export const paymentsPerUser = +process.env.SEED_PAYMENTS_PER_USER!;
export const requestsPerUser = +process.env.SEED_REQUESTS_PER_USER!;
export const bankAccountsPerUser = +process.env.SEED_BANK_ACCOUNTS_PER_USER!;
export const likesPerUser = +process.env.SEED_LIKES_PER_USER!;
export const commentsPerUser = +process.env.SEED_COMMENTS_PER_USER!;
export const notificationsPerUser = +process.env.SEED_NOTIFICATIONS_PER_USER!;
export const bankTransfersPerUser = +process.env.SEED_BANK_TRANSFERS_PER_USER!;
export const defaultPassword = process.env.SEED_DEFAULT_USER_PASSWORD!;

export const paymentVariations = 2;
export const requestVariations = 3;
// transactions per user = paymentsPerUser * paymentVariations * sender/receiver(2)
// +
// requestsPerUser * requestVariations * sender/receiver(2)
export const transactionsPerUser =
  paymentsPerUser * paymentVariations * 2 + requestsPerUser * requestVariations * 2;
export const totalTransactions = userbaseSize! * transactionsPerUser!;
export const totalLikes = userbaseSize! * likesPerUser!;
export const totalComments = userbaseSize! * commentsPerUser!;
export const totalNotifications = userbaseSize! * notificationsPerUser!;
export const totalContacts = userbaseSize! * contactsPerUser!;
export const totalBankTransfers = userbaseSize! * bankTransfersPerUser * 2; // deposit & withdrawal

export const isPayment = (type: string) => type === "payment";
export const passwordHash = bcrypt.hashSync(defaultPassword, 10);

const requestScenarios: TransactionScenario[] = [
  {
    status: TransactionStatus.pending,
    requestStatus: "pending",
  },
  {
    status: TransactionStatus.complete,
    requestStatus: "accepted",
  },
  {
    status: TransactionStatus.complete,
    requestStatus: "rejected",
  },
];

const paymentScenarios: TransactionScenario[] = [
  {
    status: TransactionStatus.pending,
    requestStatus: "",
  },
  {
    status: TransactionStatus.complete,
    requestStatus: "",
  },
];

export const getRandomTransactions = (baseCount: number, baseTransactions: Transaction[]) =>
  compact(
    uniqBy(
      "id",
      times(() => sample(baseTransactions), baseCount * 3)
    )
  ).slice(0, baseCount);

export const getUserAvatar = (identifier: string) => {
  return `https://avatars.dicebear.com/api/human/${identifier}.svg`;
};

export const createFakeUser = (): User => {
  const id = shortid();
  return {
    id,
    uuid: faker.random.uuid(),
    firstName: faker.name.firstName(),
    lastName: faker.name.lastName(),
    username: faker.internet.userName(),
    password: passwordHash,
    email: faker.internet.email(),
    phoneNumber: faker.phone.phoneNumberFormat(0),
    avatar: getUserAvatar(id),
    defaultPrivacyLevel: faker.helpers.randomize([
      DefaultPrivacyLevel.public,
      DefaultPrivacyLevel.private,
      DefaultPrivacyLevel.contacts,
    ]),
    balance: faker.random.number({ min: 10000, max: 200000 }),
    createdAt: faker.date.past(),
    modifiedAt: faker.date.recent(),
  };
};

// @ts-ignore
export const createSeedUsers = () => times(() => createFakeUser(), userbaseSize);

export const createContact = (userId: User["id"], contactUserId: User["id"]) => ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  contactUserId,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

// returns a random user other than the one passed in
export const getOtherRandomUser = curry(
  (seedUsers: User[], userId: User["id"]): User => flow(reject(["id", userId]), sample)(seedUsers)
);

export const randomContactsForUser = curry((seedUsers: User[], user: User) =>
  uniqBy(
    "id",
    times(() => getOtherRandomUser(seedUsers, user.id), contactsPerUser * 3)
  ).slice(0, contactsPerUser)
);
export const generateRandomContactsForUser = (seedUsers: User[]) =>
  map((user: User) => ({
    userId: user.id,
    contacts: randomContactsForUser(seedUsers, user),
  }))(seedUsers);

export const createContactsForUser = curry((randomContacts: any) =>
  flattenDeep(
    map((item: any) =>
      map((contact: User) => createContact(item.userId, contact.id))(item.contacts)
    )(randomContacts)
  )
);

export const createSeedContacts = (seedUsers: User[]) => {
  return flow(generateRandomContactsForUser, createContactsForUser)(seedUsers);
};

export const createSeedBankAccounts = (seedUsers: User[]) =>
  map(
    (user: User): BankAccount => {
      return {
        id: shortid(),
        uuid: faker.random.uuid(),
        userId: user.id,
        bankName: `${faker.company.companyName()} Bank`,
        accountNumber: faker.finance.account(10),
        routingNumber: faker.finance.account(9),
        isDeleted: false,
        createdAt: faker.date.past(),
        modifiedAt: faker.date.recent(),
      };
    }
  )(seedUsers);

// Transactions

export const createTransaction = (
  type: "payment" | "request",
  account: BankAccount,
  details: FakeTransaction
): Transaction => {
  const { senderId, receiverId } = details;

  const createdAt = faker.date.past();
  const modifiedAt = faker.date.recent();

  const status = faker.helpers.randomize([TransactionStatus.pending, TransactionStatus.complete]);

  let requestStatus = "";

  if (type === "request") {
    requestStatus = TransactionRequestStatus.pending;

    if (status === TransactionStatus.complete) {
      requestStatus = faker.helpers.randomize([
        TransactionRequestStatus.accepted,
        TransactionRequestStatus.rejected,
      ]);
    }
  }

  const requestResolvedAt =
    requestStatus === TransactionRequestStatus.pending
      ? ""
      : faker.date.future(undefined, createdAt);

  return {
    id: shortid(),
    uuid: faker.random.uuid(),
    source: account.id,
    amount: getFakeAmount(),
    description: isPayment(type)
      ? `Payment: ${senderId} to ${receiverId}`
      : `Request: ${receiverId} to ${senderId}`,
    privacyLevel: faker.helpers.randomize([
      DefaultPrivacyLevel.public,
      DefaultPrivacyLevel.private,
      DefaultPrivacyLevel.contacts,
    ]),
    receiverId,
    senderId,
    balanceAtCompletion: getFakeAmount(),
    status,
    requestStatus,
    requestResolvedAt,
    createdAt,
    modifiedAt,
  };
};

export const createPayment = (account: BankAccount, user: User, randomUser: User) => {
  const allScenarios = paymentScenarios.map((details) => {
    const paymentTransaction = createTransaction("payment", account, {
      senderId: user.id,
      receiverId: randomUser.id,
      ...details,
    });

    const paymentInverseTransaction = createTransaction("payment", account, {
      senderId: randomUser.id,
      receiverId: user.id,
      ...details,
    });

    return [paymentTransaction, paymentInverseTransaction];
  });

  return flattenDeep(allScenarios);
};

export const createRequest = (account: BankAccount, user: User, randomUser: User) => {
  const allScenarios = requestScenarios.map((details) => {
    const requestTransaction = createTransaction("request", account, {
      senderId: user.id,
      receiverId: randomUser.id,
      ...details,
    });

    const requestInverseTransaction = createTransaction("request", account, {
      senderId: randomUser.id,
      receiverId: user.id,
      ...details,
    });

    return [requestTransaction, requestInverseTransaction];
  });

  return flattenDeep(allScenarios);
};

export const getBankAccountsByUserId = (
  seedBankAccounts: BankAccount[],
  userId: User["id"]
): BankAccount[] => filter(flow(get("userId"), isEqual(userId)), seedBankAccounts);

export const getTransactionsByUserId = (
  seedTransactions: Transaction[],
  userId: User["id"]
): Transaction[] =>
  filter(
    ({ senderId, receiverId }) => isEqual(senderId, userId) || isEqual(receiverId, userId),
    seedTransactions
  );

export const createSeedTransactions = (seedUsers: User[], seedBankAccounts: BankAccount[]) =>
  flattenDepth(
    2,
    map((user: User): Transaction[] => {
      const accounts = getBankAccountsByUserId(seedBankAccounts, user.id);

      return flattenDepth(
        2,
        map((account: BankAccount): Transaction[] => {
          const randomUser = getOtherRandomUser(seedUsers, user.id);
          // @ts-ignore
          const payments = times(() => createPayment(account, user, randomUser), paymentsPerUser);
          // @ts-ignore
          const requests = times(() => createRequest(account, user, randomUser), requestsPerUser);

          const allScenarios = flattenDeep(concat(payments, requests));
          const requestedTransaction = filter(requestScenarios[0], allScenarios)[0];
          const chargedTransaction = filter(requestScenarios[1], allScenarios)[0];
          const paidTransaction = filter(paymentScenarios[1], allScenarios)[0];

          const testTransactions = [paidTransaction, requestedTransaction, chargedTransaction];

          const remainingScenarios = differenceBy(get("id"), allScenarios, testTransactions);

          // @ts-ignore
          return flattenDeep(concat(testTransactions, remainingScenarios));
        })(accounts)
      );
    })(seedUsers)
  );

export const createFakeLike = (userId: string, transactionId: string): Like => ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  transactionId,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const getPublicTransactionsForOtherUsers = (
  seedTransactions: Transaction[],
  userId: User["id"]
): Transaction[] =>
  flow(
    filter({ privacyLevel: DefaultPrivacyLevel.public }),
    filter(flow(get("senderId"), negate(isEqual(userId)))),
    filter(flow(get("receiverId"), negate(isEqual(userId))))
  )(seedTransactions);

export const createSeedLikes = (seedUsers: User[], seedTransactions: Transaction[]) =>
  flattenDeep(
    map((user: User): Like[] => {
      const transactions = getPublicTransactionsForOtherUsers(seedTransactions, user.id);

      // choose random transactions
      const randomTransactions = getRandomTransactions(10, transactions);

      // get a slice of random transactions
      const selectedTransactions = sampleSize(
        likesPerUser,
        compact(randomTransactions.slice(0, likesPerUser * 2))
      );

      // iterate over transactions and like
      return selectedTransactions.map((transaction) => createFakeLike(user.id, transaction!.id));
    })(seedUsers)
  );

export const createFakeComment = (userId: string, transactionId: string): Comment => ({
  id: shortid(),
  uuid: faker.random.uuid(),
  content: faker.lorem.words(),
  userId,
  transactionId,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const createSeedComments = (seedUsers: User[], seedTransactions: Transaction[]) =>
  flattenDeep(
    map((user: User): Comment[] => {
      const transactions = getPublicTransactionsForOtherUsers(seedTransactions, user.id);

      // choose random transactions
      const randomTransactions = getRandomTransactions(5, transactions);

      // get a slice of random transactions
      const selectedTransactions = randomTransactions.slice(0, commentsPerUser);

      // iterate over transactions and comment
      return selectedTransactions.map((transaction) => createFakeComment(user.id, transaction!.id));
    })(seedUsers)
  );

export const createFakePaymentNotification = (
  userId: string,
  transaction: Transaction,
  status: PaymentNotificationStatus
): PaymentNotification => ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  transactionId: transaction.id,
  status,
  isRead: false,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const createFakeLikeNotification = (
  userId: string,
  transactionId: string,
  likeId: string
): LikeNotification => ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  likeId,
  transactionId,
  isRead: false,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const createFakeCommentNotification = (
  userId: string,
  transactionId: string,
  commentId: string
): CommentNotification => ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  commentId,
  transactionId,
  isRead: false,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

const getTransactionsWithLikes = (transactions: Transaction[], seedLikes: Like[]) =>
  intersectionWith(
    ({ id: transactionId }, { transactionId: likeTransactionId }) =>
      isEqual(transactionId, likeTransactionId),
    transactions,
    seedLikes
  );

const getLikeByTransactionId = (transactionId: Transaction["id"], seedLikes: Like[]) =>
  find({ transactionId }, seedLikes) as Like;

const getTransactionsWithComments = (transactions: Transaction[], seedComments: Comment[]) =>
  intersectionWith(
    ({ id: transactionId }, { transactionId: commentTransactionId }) =>
      isEqual(transactionId, commentTransactionId),
    transactions,
    seedComments
  );

const getCommentByTransactionId = (transactionId: Transaction["id"], seedComments: Comment[]) =>
  find({ transactionId }, seedComments) as Comment;

export const createSeedNotifications = (
  seedUsers: User[],
  seedTransactions: Transaction[],
  seedLikes: Like[],
  seedComments: Comment[]
) =>
  flattenDeep(
    map((user: User): NotificationType[] => {
      const transactions = getPublicTransactionsForOtherUsers(seedTransactions, user.id);

      const transactionsWithLikes = getTransactionsWithLikes(transactions, seedLikes);

      const transactionsWithComments = getTransactionsWithComments(transactions, seedComments);

      const likeTransaction = sample(compact(getRandomTransactions(5, transactionsWithLikes)));
      const like = getLikeByTransactionId(likeTransaction!.id, seedLikes);
      const likeNotification = createFakeLikeNotification(user.id, likeTransaction!.id, like!.id);

      const commentTransaction = sample(
        compact(getRandomTransactions(5, transactionsWithComments))
      );
      const comment = getCommentByTransactionId(commentTransaction!.id, seedComments);
      // comment notification
      const commentNotification = createFakeCommentNotification(
        user.id,
        commentTransaction!.id,
        comment!.id
      );

      // choose random transactions
      const randomTransactions = getRandomTransactions(notificationsPerUser - 2, transactions);

      const paymentRequestNotifications = randomTransactions.map((transaction) =>
        createFakePaymentNotification(user.id, transaction!, PaymentNotificationStatus.requested)
      );

      const paymentReceivedNotifications = randomTransactions.map((transaction) =>
        createFakePaymentNotification(user.id, transaction!, PaymentNotificationStatus.received)
      );

      let allNotifications = [likeNotification, commentNotification];

      return flattenDeep(
        // @ts-ignore
        concat(allNotifications, [paymentRequestNotifications, paymentReceivedNotifications])
      ) as NotificationType[];
    })(seedUsers)
  );

export const createBankTransfer = (
  transferType: BankTransferType,
  userId: User["id"],
  transactionId: Transaction["id"],
  bankAccountId: BankAccount["id"]
): BankTransfer => ({
  id: shortid(),
  uuid: faker.random.uuid(),
  userId,
  source: bankAccountId,
  amount: getFakeAmount(),
  type: transferType,
  transactionId,
  createdAt: faker.date.past(),
  modifiedAt: faker.date.recent(),
});

export const createSeedBankTransfers = (
  seedUsers: User[],
  seedTransactions: Transaction[],
  seedBankAccounts: BankAccount[]
) =>
  flattenDepth(
    2,
    map((user: User): BankTransfer[] => {
      const userTransactions: Transaction[] = getTransactionsByUserId(seedTransactions, user.id);
      const bankAccounts = getBankAccountsByUserId(seedBankAccounts, user.id);

      // choose random transactions
      const randomTransactions = getRandomTransactions(
        bankTransfersPerUser,
        userTransactions
      ) as Transaction[];

      return flattenDepth(
        2,
        map((transaction: Transaction): BankTransfer[] => {
          const deposit = createBankTransfer(
            BankTransferType.deposit,
            user.id,
            transaction.id,
            bankAccounts[0].id
          );
          const withdrawal = createBankTransfer(
            BankTransferType.withdrawal,
            user.id,
            transaction.id,
            bankAccounts[0].id
          );

          return [deposit, withdrawal];
        })(randomTransactions)
      );
    })(seedUsers)
  );

export const buildDatabase = () => {
  const seedUsers: User[] = createSeedUsers();
  const seedContacts: Contact[] = createSeedContacts(seedUsers);
  const seedBankAccounts: BankAccount[] = createSeedBankAccounts(seedUsers);
  const seedTransactions: Transaction[] = createSeedTransactions(seedUsers, seedBankAccounts);
  const seedLikes: Like[] = createSeedLikes(seedUsers, seedTransactions);
  const seedComments: Comment[] = createSeedComments(seedUsers, seedTransactions);
  const seedNotifications: NotificationType[] = createSeedNotifications(
    seedUsers,
    seedTransactions,
    seedLikes,
    seedComments
  );
  const seedBankTransfers: BankTransfer[] = createSeedBankTransfers(
    seedUsers,
    seedTransactions,
    seedBankAccounts
  );

  return {
    users: seedUsers,
    contacts: seedContacts,
    bankaccounts: seedBankAccounts,
    transactions: seedTransactions,
    likes: seedLikes,
    comments: seedComments,
    notifications: seedNotifications,
    banktransfers: seedBankTransfers,
  };
};



================================================
FILE: cypress-realworld-app/scripts/testServer.ts
================================================
import path from "path";
import express from "express";
import history from "connect-history-api-fallback";
import setupProxy from "../src/setupProxy";

const app = express();

setupProxy(app);

app.use(history());
app.use(express.static(path.join(__dirname, "../build")));

app.listen(3000);



================================================
FILE: cypress-realworld-app/scripts/tsconfig.json
================================================
{
  "extends": "../tsconfig.json",
  "include": ["./*/*.ts", "../src", "../models"],
  "exclude": [],
  "compilerOptions": {
    "types": ["node"],
    "isolatedModules": false
  }
}



================================================
FILE: cypress-realworld-app/src/index.tsx
================================================
import React from "react";
import ReactDOM from "react-dom";
import { Router } from "react-router-dom";
import { history } from "./utils/historyUtils";

import App from "./containers/App";
import { createMuiTheme, ThemeProvider } from "@material-ui/core";

const theme = createMuiTheme({
  palette: {
    secondary: {
      main: "#fff",
    },
  },
});

ReactDOM.render(
  <Router history={history}>
    <ThemeProvider theme={theme}>
      <App />
    </ThemeProvider>
  </Router>,
  document.getElementById("root")
);



================================================
FILE: cypress-realworld-app/src/react-app-env.d.ts
================================================
/// <reference types="react-scripts" />



================================================
FILE: cypress-realworld-app/src/setupProxy.js
================================================
const createProxyMiddleware = require("http-proxy-middleware");

module.exports = function (app) {
  app.use(
    createProxyMiddleware(["/login", "/callback", "/logout", "/checkAuth"], {
      target: `http://localhost:3001`,
      changeOrigin: true,
      logLevel: "debug",
    })
  );
};



================================================
FILE: cypress-realworld-app/src/__tests__/bankaccounts.test.ts
================================================
import faker from "faker";
import {
  getBankAccountById,
  getBankAccountsByUserId,
  getRandomUser,
  seedDatabase,
  createBankAccountForUser,
  removeBankAccountById,
} from "../../backend/database";
import { User } from "../../src/models/user";
import { BankAccount } from "../../src/models/bankaccount";
describe("BankAccounts", () => {
  beforeEach(() => {
    seedDatabase();
  });

  it("should retrieve a list of bank accounts for a user", () => {
    const userToLookup: User = getRandomUser();

    const result = getBankAccountsByUserId(userToLookup.id);
    expect(result[0].userId).toBe(userToLookup.id);
  });

  it("should retrieve a bank accounts by id", () => {
    const userToLookup: User = getRandomUser();

    const accounts = getBankAccountsByUserId(userToLookup.id);
    const bankAccountId = accounts[0].id;

    const account = getBankAccountById(bankAccountId);

    expect(account.id).toEqual(bankAccountId);
  });

  it("should create a bank account for user", () => {
    const user: User = getRandomUser();
    const accountNumber = faker.finance.account(10);

    const accountDetails: Partial<BankAccount> = {
      bankName: `${faker.company.companyName()} Bank`,
      accountNumber,
      routingNumber: faker.finance.account(9),
    };
    const result = createBankAccountForUser(user.id, accountDetails);
    expect(result.userId).toBe(user.id);
  });

  it("should delete a bank account", () => {
    const userToLookup: User = getRandomUser();

    const accounts = getBankAccountsByUserId(userToLookup.id);
    const bankAccountId = accounts[0].id;

    removeBankAccountById(bankAccountId);

    const updatedBankAccounts = getBankAccountsByUserId(userToLookup.id);
    expect(updatedBankAccounts[0].isDeleted).toBe(true);
  });
});



================================================
FILE: cypress-realworld-app/src/__tests__/comments.test.ts
================================================
import {
  seedDatabase,
  getTransactionsForUserContacts,
  getAllUsers,
  getTransactionsByUserId,
  createComment,
  getCommentsByTransactionId,
} from "../../backend/database";

import { User, Transaction } from "../../src/models";

describe("Comments", () => {
  beforeEach(() => {
    seedDatabase();
  });

  it("should comment a transaction for a contact", () => {
    const user: User = getAllUsers()[0];
    const transactions: Transaction[] = getTransactionsForUserContacts(user.id);

    const content = "This is my comment content";
    const comment = createComment(user.id, transactions[0].id, content);

    expect(comment.transactionId).toBe(transactions[0].id);
    expect(comment.content).toBe(content);
  });

  it("should get a list of comments for a transaction", () => {
    const user: User = getAllUsers()[0];
    const transactions: Transaction[] = getTransactionsByUserId(user.id);
    const transaction = transactions[0];

    createComment(user.id, transaction.id, "This is my comment");

    const comments = getCommentsByTransactionId(transaction.id);

    expect(comments[0].transactionId).toBe(transaction.id);
  });
});



================================================
FILE: cypress-realworld-app/src/__tests__/contacts.test.ts
================================================
import {
  createContactForUser,
  getContactsByUsername,
  getAllContacts,
  getAllUsers,
  getRandomUser,
  seedDatabase,
  removeContactById,
  getContactsByUserId,
} from "../../backend/database";
import { User } from "../../src/models/user";
import { totalContacts, contactsPerUser } from "../../scripts/seedDataUtils";
describe("Contacts", () => {
  beforeEach(() => {
    seedDatabase();
  });

  it("should retrieve a list of contacts", () => {
    expect(getAllContacts().length).toEqual(totalContacts);
  });

  it("should retrieve a list of contacts for a username", () => {
    const userToLookup: User = getAllUsers()[0];

    const result = getContactsByUsername(userToLookup.username);
    expect(result.length).toBeGreaterThanOrEqual(contactsPerUser);
    expect(result[0].userId).toBe(userToLookup.id);
  });

  it("should retrieve a list of contacts for a userId", () => {
    const userToLookup: User = getAllUsers()[0];

    const result = getContactsByUserId(userToLookup.id);
    expect(result.length).toBeGreaterThanOrEqual(3);
    expect(result[0].userId).toBe(userToLookup.id);
  });

  it("should create a contact for user", () => {
    const user: User = getRandomUser();
    const contactToBe: User = getRandomUser();

    const result = createContactForUser(user.id, contactToBe.id);
    expect(result.userId).toBe(user.id);
  });

  it("should delete a contact", () => {
    const userToLookup: User = getRandomUser();

    const contacts = getContactsByUsername(userToLookup.username);

    const contactId = contacts[0].id;

    removeContactById(contactId);

    const updatedContacts = getContactsByUsername(userToLookup.username);
    expect(updatedContacts.length).toBeLessThan(contacts.length);
  });
});



================================================
FILE: cypress-realworld-app/src/__tests__/generateSeedData.test.ts
================================================
import {
  buildDatabase,
  userbaseSize,
  contactsPerUser,
  totalTransactions,
  bankAccountsPerUser,
  totalLikes,
  totalComments,
  totalNotifications,
  totalBankTransfers,
} from "../../scripts/seedDataUtils";
import { TDatabase } from "../../backend/database";

describe.skip("Seed Database", () => {
  let database: TDatabase;
  beforeEach(() => {
    database = buildDatabase();
  });

  it("should contain a list of users", () => {
    expect(database).toHaveProperty("users");
    expect(database.users.length).toBe(userbaseSize);
  });

  it("should contain a list of contacts", () => {
    expect(database).toHaveProperty("contacts");
    expect(database.contacts.length).toBe(contactsPerUser * userbaseSize);
  });

  it("should contain a list of bankaccounts", () => {
    expect(database).toHaveProperty("bankaccounts");
    expect(database.bankaccounts.length).toBe(bankAccountsPerUser * userbaseSize);
  });

  it("should contain a list of transactions", () => {
    expect(database).toHaveProperty("transactions");
    expect(database.transactions.length).toBe(totalTransactions);
  });

  it("should contain a list of likes", () => {
    expect(database).toHaveProperty("likes");
    expect(database.likes.length).toBe(totalLikes);
  });

  it("should contain a list of comments", () => {
    expect(database).toHaveProperty("comments");
    expect(database.comments.length).toBe(totalComments);
  });

  it("should contain a list of notifications", () => {
    expect(database).toHaveProperty("notifications");
    expect(database.notifications.length).toBeGreaterThanOrEqual(totalNotifications);
  });

  it("should contain a list of bank transfers", () => {
    expect(database).toHaveProperty("banktransfers");
    expect(database.banktransfers.length).toBeLessThanOrEqual(totalBankTransfers);
  });
});



================================================
FILE: cypress-realworld-app/src/__tests__/likes.test.ts
================================================
import {
  seedDatabase,
  getTransactionsForUserContacts,
  getAllUsers,
  getTransactionsByUserId,
  createLike,
  getLikesByTransactionId,
} from "../../backend/database";

import { User, Transaction } from "../../src/models";

describe("Transactions", () => {
  beforeEach(() => {
    seedDatabase();
  });

  it("should like a transaction for a contact", () => {
    const user: User = getAllUsers()[0];
    const transactions: Transaction[] = getTransactionsForUserContacts(user.id);

    const like = createLike(user.id, transactions[0].id);

    expect(like.transactionId).toBe(transactions[0].id);
  });

  it("should get a list of likes for a transaction", () => {
    const user: User = getAllUsers()[0];
    const transactions: Transaction[] = getTransactionsByUserId(user.id);
    const transaction = transactions[0];

    createLike(user.id, transaction.id);

    const likes = getLikesByTransactionId(transaction.id);

    expect(likes[0].transactionId).toBe(transaction.id);
  });
});



================================================
FILE: cypress-realworld-app/src/__tests__/notifications.test.ts
================================================
import {
  seedDatabase,
  getTransactionsForUserContacts,
  getAllUsers,
  createPaymentNotification,
  createLikeNotification,
  createLike,
  createComment,
  createCommentNotification,
  getTransactionsByUserId,
  getNotificationsByUserId,
  createNotifications,
  updateNotificationById,
  getNotificationById,
  formatNotificationForApiResponse,
} from "../../backend/database";

import {
  User,
  Transaction,
  PaymentNotificationStatus,
  PaymentNotification,
  Like,
  Comment,
  LikeNotification,
  CommentNotification,
  NotificationsType,
  NotificationType,
} from "../../src/models";

describe("Notifications", () => {
  let user: User;
  beforeEach(() => {
    seedDatabase();
    user = getAllUsers()[0];
  });

  describe("create notifications", () => {
    let transactions: Transaction[];
    let transaction: Transaction;
    let paymentNotification: PaymentNotification;
    let like: Like;
    let likeNotification: LikeNotification;
    let comment: Comment;
    let commentNotification: CommentNotification;
    beforeEach(() => {
      user = getAllUsers()[0];
      transactions = getTransactionsForUserContacts(user.id);
      transaction = transactions[0];
      paymentNotification = createPaymentNotification(
        user.id,
        transaction.id,
        PaymentNotificationStatus.received
      );
      like = createLike(user.id, transaction.id);
      likeNotification = createLikeNotification(user.id, transaction.id, like.id);
      comment = createComment(user.id, transaction.id, "This is my comment");

      commentNotification = createCommentNotification(user.id, transaction.id, comment.id);
    });

    it("should create a payment notification for a transaction", () => {
      expect(paymentNotification.transactionId).toBe(transaction.id);
      expect(paymentNotification.status).toBe(PaymentNotificationStatus.received);
    });

    it("should create a like notification for a transaction", () => {
      expect(likeNotification.transactionId).toBe(transaction.id);
      expect(likeNotification.likeId).toBe(like.id);
    });

    it("should create a comment notification for a transaction", () => {
      expect(commentNotification.transactionId).toBe(transaction.id);
      expect(commentNotification.commentId).toBe(comment.id);
    });

    it("should format comment notification for api", () => {
      const apiNotification = formatNotificationForApiResponse(commentNotification);
      expect(apiNotification.userFullName).toBeDefined();
    });

    it("should create notifications for a transaction", () => {
      const notificationsPayload = [
        {
          type: NotificationsType.payment,
          transactionId: transaction.id,
          status: PaymentNotificationStatus.received,
        },
        {
          type: NotificationsType.like,
          transactionId: transaction.id,
          likeId: like.id,
        },
        {
          type: NotificationsType.comment,
          transactionId: transaction.id,
          commentId: comment.id,
        },
      ];

      const notifications = createNotifications(user.id, notificationsPayload);

      expect(notifications[0]!.transactionId).toBe(transaction.id);
      // @ts-ignore
      expect(notifications[1]!.likeId).toBe(like.id);
      // @ts-ignore
      expect(notifications[2]!.commentId).toBe(comment.id);
    });
  });

  it("should get a list of notifications for a user", () => {
    const transactions: Transaction[] = getTransactionsByUserId(user.id);
    const transaction = transactions[0];

    // create comment and like and notifications for transaction
    const comment = createComment(user.id, transaction.id, "This is my notification content");
    createCommentNotification(user.id, transaction.id, comment.id);
    const like = createLike(user.id, transaction.id);
    createLikeNotification(user.id, transaction.id, like.id);

    const notifications = getNotificationsByUserId(user.id);

    expect(notifications.length).toBeGreaterThan(1);
    expect(notifications[notifications.length - 1]).toMatchObject({
      transactionId: transaction.id,
    });
  });

  it("should update a notification", () => {
    const notifications = getNotificationsByUserId(user.id);
    const edits: Partial<NotificationType> = {
      isRead: true,
    };
    // @ts-ignore
    updateNotificationById(user.id, notifications[0].id, edits);

    // @ts-ignore
    const updatedNotification = getNotificationById(notifications[0].id);
    expect(updatedNotification.isRead).toBe(true);
  });
});



================================================
FILE: cypress-realworld-app/src/__tests__/transactions.test.ts
================================================
import { map } from "lodash/fp";
import {
  seedDatabase,
  getTransactionsForUserByObj,
  getTransactionsForUserContacts,
  getAllUsers,
  getAllTransactions,
  getAllPublicTransactions,
  getBankAccountsByUserId,
  createTransaction,
  getTransactionsByUserId,
  updateTransactionById,
  getTransactionById,
  getPublicTransactionsDefaultSort,
  getUserById,
  getBankTransferByTransactionId,
} from "../../backend/database";

import {
  User,
  Transaction,
  TransactionRequestStatus,
  DefaultPrivacyLevel,
  BankTransferType,
  TransactionPayload,
  TransactionStatus,
} from "../../src/models";
import { getFakeAmount } from "../../src/utils/transactionUtils";
import { totalTransactions, transactionsPerUser } from "../../scripts/seedDataUtils";

describe("Transactions", () => {
  beforeEach(() => {
    seedDatabase();
  });

  it("should retrieve a list of all transactions", () => {
    expect(getAllTransactions().length).toBe(totalTransactions);
  });

  it("should retrieve a list of all public transactions", () => {
    expect(getAllPublicTransactions().length).toBeGreaterThan(transactionsPerUser);
    expect(getAllPublicTransactions().length).toBeLessThan(totalTransactions);
  });

  it("should retrieve a list of transactions for a user (user is receiver)", () => {
    const userToLookup: User = getAllUsers()[0];

    const result: Transaction[] = getTransactionsForUserByObj(userToLookup.id, {
      status: "complete",
    });
    expect(result[0].receiverId).toBe(userToLookup.id);
  });

  it("should retrieve a list of transactions for a user (user is sender)", () => {
    const userToLookup: User = getAllUsers()[0];

    const result: Transaction[] = getTransactionsForUserByObj(userToLookup.id, {});
    expect(result.pop()!.senderId).toBe(userToLookup.id);
  });

  it("should retrieve a list of transactions for a users contacts", () => {
    const userToLookup: User = getAllUsers()[0];
    const result: Transaction[] = getTransactionsForUserContacts(userToLookup.id);

    expect(result.length).toBeGreaterThan(transactionsPerUser);
    expect(result.length).toBeLessThan(totalTransactions);
  });

  it("should retrieve a list of transactions for a users contacts - between date range", () => {
    const userToLookup: User = getAllUsers()[0];
    const result: Transaction[] = getTransactionsForUserContacts(userToLookup.id, {
      dateRangeStart: new Date("Dec 01 2019"),
      dateRangeEnd: new Date("Dec 05 2019"),
    });
    expect(result.length).toBeGreaterThan(1);
  });

  it("should retrieve a list of public transactions, default sort", () => {
    const user: User = getAllUsers()[0];
    const contactsTransactions: Transaction[] = getTransactionsForUserContacts(user.id);
    expect(contactsTransactions.length).toBeGreaterThan(1);
    expect(contactsTransactions.length).toBeLessThan(totalTransactions);

    const response = getPublicTransactionsDefaultSort(user.id);

    expect(response.contactsTransactions.length).toBeGreaterThan(1);
    expect(response.contactsTransactions.length).toBeLessThan(totalTransactions);
    expect(response.publicTransactions.length).toBeGreaterThan(1);
    expect(response.publicTransactions.length).toBeLessThan(totalTransactions);

    const ids = map("id", contactsTransactions);
    expect(ids).toContain(response.contactsTransactions[9].id);
  });

  it("should create a payment", () => {
    const sender: User = getAllUsers()[0];
    const receiver: User = getAllUsers()[1];
    const senderBankAccount = getBankAccountsByUserId(sender.id)[0];

    const paymentDetails: TransactionPayload = {
      source: senderBankAccount.id!,
      senderId: sender.id,
      receiverId: receiver.id,
      description: `Payment: ${sender.id} to ${receiver.id}`,
      amount: getFakeAmount(),
      privacyLevel: DefaultPrivacyLevel.public,
      status: TransactionStatus.pending,
    };

    const result = createTransaction(sender.id, "payment", paymentDetails);
    expect(result.id).toBeDefined();
    expect(result.status).toEqual("complete");
    expect(result.requestStatus).not.toBeDefined();
  });

  it("should create a request", () => {
    const sender: User = getAllUsers()[0];
    const receiver: User = getAllUsers()[1];
    const senderBankAccount = getBankAccountsByUserId(sender.id)[0];

    const requestDetails: TransactionPayload = {
      source: senderBankAccount.id!,
      senderId: sender.id,
      receiverId: receiver.id,
      description: `Request: ${sender.id} to ${receiver.id}`,
      amount: getFakeAmount(),
      privacyLevel: DefaultPrivacyLevel.public,
      status: TransactionStatus.pending,
    };

    const result = createTransaction(sender.id, "request", requestDetails);
    expect(result.id).toBeDefined();
    expect(result.status).toEqual("pending");
    expect(result.requestStatus).toEqual("pending");
  });

  it("should create a payment and find it in the personal transactions", () => {
    const sender: User = getAllUsers()[0];
    const receiver: User = getAllUsers()[1];
    const senderBankAccount = getBankAccountsByUserId(sender.id)[0];

    const paymentDetails: TransactionPayload = {
      source: senderBankAccount.id!,
      senderId: sender.id,
      receiverId: receiver.id,
      description: `Payment: ${sender.id} to ${receiver.id}`,
      amount: getFakeAmount(),
      privacyLevel: DefaultPrivacyLevel.private,
      status: TransactionStatus.pending,
    };

    const payment = createTransaction(sender.id, "payment", paymentDetails);
    expect(payment.id).toBeDefined();

    const personalTransactions: Transaction[] = getTransactionsForUserByObj(sender.id, {});
    const ids = map("id", personalTransactions);
    expect(ids).toContain(payment.id);
  });

  it("should reject (update) a transaction", () => {
    const user: User = getAllUsers()[0];

    const transactions = getTransactionsByUserId(user.id);
    expect(transactions.length).toBeGreaterThanOrEqual(transactionsPerUser);

    const transaction = transactions[0];
    expect(transaction.requestStatus).not.toEqual("rejected");

    const edits: Partial<Transaction> = {
      requestStatus: TransactionRequestStatus.rejected,
    };
    updateTransactionById(transaction.id, edits);

    const updatedTransaction = getTransactionById(transaction.id);
    expect(updatedTransaction.requestStatus).toEqual("rejected");
  });

  it("should accept (update) a transaction", () => {
    const user: User = getAllUsers()[0];

    const transactions = getTransactionsByUserId(user.id);
    expect(transactions.length).toBeGreaterThanOrEqual(transactionsPerUser);

    const transaction = transactions[0];
    expect(transaction.requestStatus).not.toEqual("accepted");

    const edits: Partial<Transaction> = {
      requestStatus: TransactionRequestStatus.accepted,
    };
    updateTransactionById(transaction.id, edits);

    const updatedTransaction = getTransactionById(transaction.id);
    expect(updatedTransaction.requestStatus).toEqual("accepted");
  });

  it("should add additional fields (e.g. retreiverName, senderName, etc) to a list of transactions for a user for API response", () => {
    const userToLookup: User = getAllUsers()[0];

    const result = getPublicTransactionsDefaultSort(userToLookup.id);

    const transaction = result.publicTransactions[0];
    const { receiverId, senderId, receiverName, senderName } = transaction;
    const receiver = getUserById(receiverId);
    const sender = getUserById(senderId);

    expect(receiverName).toBe(`${receiver.firstName} ${receiver.lastName}`);
    expect(senderName).toBe(`${sender.firstName} ${sender.lastName}`);
    expect(transaction.likes).toBeDefined();
    expect(transaction.comments).toBeDefined();
  });

  it.skip("should create a payment and withdrawal (bank transfer) for remaining balance", () => {
    const sender: User = getAllUsers()[0];
    const receiver: User = getAllUsers()[1];
    const senderBankAccount = getBankAccountsByUserId(sender.id)[0];
    const firstPaymentAmount = 1000;
    const secondPaymentAmount = 500;

    const receiverTransactions = getTransactionsByUserId(receiver.id);
    expect(receiverTransactions.length).toBeGreaterThan(1);

    console.log("sender balance:", sender.balance + 1000);
    const paymentDetails: TransactionPayload = {
      source: senderBankAccount.id!,
      senderId: sender.id,
      receiverId: receiver.id,
      description: `Payment: ${sender.id} to ${receiver.id}`,
      amount: sender.balance + firstPaymentAmount,
      privacyLevel: DefaultPrivacyLevel.public,
      status: TransactionStatus.pending,
    };

    const transaction = createTransaction(sender.id, "payment", paymentDetails);
    expect(transaction.id).toBeDefined();
    expect(transaction.status).toEqual("complete");
    expect(transaction.requestStatus).not.toBeDefined();

    const updatedSender: User = getAllUsers()[0];
    expect(updatedSender.balance).toBe(0);

    const withdrawal = getBankTransferByTransactionId(transaction.id);
    expect(withdrawal.type).toBe(BankTransferType.withdrawal);
    expect(withdrawal.amount).toBe(firstPaymentAmount);

    // second transaction - $500
    const secondPaymentDetails: TransactionPayload = {
      source: senderBankAccount.id!,
      senderId: sender.id,
      receiverId: receiver.id,
      description: `Payment: ${sender.id} to ${receiver.id}`,
      amount: secondPaymentAmount,
      privacyLevel: DefaultPrivacyLevel.public,
      status: TransactionStatus.pending,
    };
    const secondTransaction = createTransaction(sender.id, "payment", secondPaymentDetails);
    expect(secondTransaction.id).toBeDefined();
    expect(secondTransaction.status).toEqual("complete");
    expect(secondTransaction.requestStatus).not.toBeDefined();

    const secondUpdatedSender: User = getAllUsers()[0];
    expect(secondUpdatedSender.balance).toBe(0);

    const secondWithdrawal = getBankTransferByTransactionId(secondTransaction.id);
    expect(secondWithdrawal.type).toBe(BankTransferType.withdrawal);
    expect(secondWithdrawal.amount).toBe(secondPaymentAmount);

    // Verify Deposit Transactions for Receiver
    const updatedReceiverTransactions = getTransactionsByUserId(receiver.id);

    expect(updatedReceiverTransactions.length).toBe(receiverTransactions.length + 2);

    // Verify Receiver's Updated App Balance
    const updatedReceiver: User = getAllUsers()[1];
    expect(updatedReceiver.balance).toBe(
      receiver.balance + firstPaymentAmount + secondPaymentAmount
    );
  });

  it.skip("should create a request and withdrawal (bank transfer) for remaining balance", () => {
    const sender: User = getAllUsers()[0];
    const receiver: User = getAllUsers()[1];
    const senderBankAccount = getBankAccountsByUserId(sender.id)[0];
    const requestAmount = 100;

    const receiverTransactions = getTransactionsByUserId(receiver.id);
    expect(receiverTransactions.length).toBeGreaterThan(1);

    const requestDetails: TransactionPayload = {
      source: senderBankAccount.id!,
      senderId: sender.id,
      receiverId: receiver.id,
      description: `Request: ${sender.id} to ${receiver.id}`,
      amount: requestAmount,
      privacyLevel: DefaultPrivacyLevel.public,
      status: TransactionStatus.pending,
    };

    const transaction = createTransaction(sender.id, "request", requestDetails);
    expect(transaction.id).toBeDefined();
    expect(transaction.status).toEqual("pending");
    expect(transaction.requestStatus).toBe(TransactionRequestStatus.pending);

    const edits: Partial<Transaction> = {
      requestStatus: TransactionRequestStatus.accepted,
    };
    updateTransactionById(transaction.id, edits);

    const updatedTransaction = getTransactionById(transaction.id);
    expect(updatedTransaction.requestStatus).toEqual("accepted");

    const updatedReceiver: User = getAllUsers()[1];
    expect(updatedReceiver.balance).toBe(receiver.balance + requestAmount);

    // Verify Deposit Transactions for Sender
    const updatedSenderTransactions = getTransactionsByUserId(sender.id);

    expect(updatedSenderTransactions.length).toBe(receiverTransactions.length + 2);

    // Verify Sender's Updated App Balance
    const updatedSender: User = getAllUsers()[0];
    expect(updatedSender.balance).toBe(sender.balance - requestAmount);
  });
});



================================================
FILE: cypress-realworld-app/src/__tests__/users.test.ts
================================================
import { seedDatabase, getAllUsers, searchUsers } from "../../backend/database";

import { User } from "../models";

describe("Users", () => {
  beforeEach(() => {
    seedDatabase();
  });

  it("should get a user by email address", () => {
    const userToLookup: User = getAllUsers()[0];
    const { email } = userToLookup;

    const users = searchUsers(email);

    expect(users.length).toBeGreaterThanOrEqual(1);
    expect(users[0].id).toBe(userToLookup.id);
  });

  it("should get a user by username", () => {
    const userToLookup: User = getAllUsers()[0];
    const { username } = userToLookup;

    const users = searchUsers(username);

    expect(users.length).toBeGreaterThanOrEqual(1);
    expect(users[0].id).toBe(userToLookup.id);
  });

  it("should get a user by phone number", () => {
    const userToLookup: User = getAllUsers()[0];
    const { phoneNumber } = userToLookup;

    const users = searchUsers(phoneNumber);

    expect(users.length).toBeGreaterThanOrEqual(1);
    expect(users[0].id).toBe(userToLookup.id);
  });

  it("should get a list of users by alpha (username, email) (fuzzy match)", () => {
    const userToLookup: User = getAllUsers()[0];
    const users = searchUsers(userToLookup.firstName);

    expect(users.length).toBeGreaterThanOrEqual(1);
  });

  it("should get a list of users by phone (fuzzy match)", () => {
    const users = searchUsers("201");

    expect(users.length).toBeGreaterThanOrEqual(1);
  });
});



================================================
FILE: cypress-realworld-app/src/components/AlertBar.tsx
================================================
import React from "react";
import { Snackbar } from "@material-ui/core";
import { Interpreter } from "xstate";
import { SnackbarContext, SnackbarSchema, SnackbarEvents } from "../machines/snackbarMachine";
import { useService } from "@xstate/react";
import Alert from "@material-ui/lab/Alert";

interface Props {
  snackbarService: Interpreter<SnackbarContext, SnackbarSchema, SnackbarEvents, any>;
}

const AlertBar: React.FC<Props> = ({ snackbarService }) => {
  const [snackbarState] = useService(snackbarService);

  return (
    <Snackbar
      anchorOrigin={{ vertical: "bottom", horizontal: "left" }}
      open={snackbarState?.matches("visible")}
      autoHideDuration={3000}
    >
      <Alert
        data-test={`alert-bar-${snackbarState?.context.severity}`}
        elevation={6}
        variant="filled"
        severity={snackbarState?.context.severity}
      >
        {snackbarState?.context.message}
      </Alert>
    </Snackbar>
  );
};

export default AlertBar;



================================================
FILE: cypress-realworld-app/src/components/BankAccountForm.tsx
================================================
import React from "react";
import TextField from "@material-ui/core/TextField";
import { makeStyles } from "@material-ui/core/styles";
import { Formik, Form, Field, FieldProps } from "formik";
import { string, object } from "yup";
import { Button, Grid } from "@material-ui/core";
import { BankAccountPayload, User } from "../models";
import { useHistory } from "react-router";

const validationSchema = object({
  bankName: string().min(5, "Must contain at least 5 characters").required("Enter a bank name"),
  routingNumber: string()
    .length(9, "Must contain a valid routing number")
    .required("Enter a valid bank routing number"),
  accountNumber: string()
    .min(9, "Must contain at least 9 digits")
    .max(12, "Must contain no more than 12 digits")
    .required("Enter a valid bank account number"),
});

const useStyles = makeStyles((theme) => ({
  paper: {
    marginTop: theme.spacing(8),
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  form: {
    width: "100%", // Fix IE 11 issue.
    marginTop: theme.spacing(1),
  },
  submit: {
    margin: theme.spacing(3, 0, 2),
  },
}));

export interface BankAccountFormProps {
  userId: User["id"];
  createBankAccount: Function;
  onboarding?: boolean;
}

const BankAccountForm: React.FC<BankAccountFormProps> = ({
  userId,
  createBankAccount,
  onboarding,
}) => {
  const history = useHistory();
  const classes = useStyles();
  const initialValues: BankAccountPayload = {
    userId,
    bankName: "",
    accountNumber: "",
    routingNumber: "",
  };

  return (
    <Formik
      initialValues={initialValues}
      validationSchema={validationSchema}
      onSubmit={(values, { setSubmitting }) => {
        setSubmitting(true);

        createBankAccount({ ...values, userId });

        if (!onboarding) {
          history.push("/bankaccounts");
        }
      }}
    >
      {({ isValid, isSubmitting }) => (
        <Form className={classes.form} data-test="bankaccount-form">
          <Field name="bankName">
            {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
              <TextField
                variant="outlined"
                margin="dense"
                fullWidth
                required
                id={"bankaccount-bankName-input"}
                type="text"
                placeholder="Bank Name"
                data-test={"bankaccount-bankName-input"}
                error={(touched || value !== initialValue) && Boolean(error)}
                helperText={touched || value !== initialValue ? error : ""}
                {...field}
              />
            )}
          </Field>
          <Field name="routingNumber">
            {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
              <TextField
                variant="outlined"
                margin="dense"
                fullWidth
                required
                id={"bankaccount-routingNumber-input"}
                type="text"
                placeholder="Routing Number"
                data-test={"bankaccount-routingNumber-input"}
                error={(touched || value !== initialValue) && Boolean(error)}
                helperText={touched || value !== initialValue ? error : ""}
                {...field}
              />
            )}
          </Field>
          <Field name="accountNumber">
            {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
              <TextField
                variant="outlined"
                margin="dense"
                fullWidth
                required
                id={"bankaccount-accountNumber-input"}
                type="text"
                placeholder="Account Number"
                data-test={"bankaccount-accountNumber-input"}
                error={(touched || value !== initialValue) && Boolean(error)}
                helperText={touched || value !== initialValue ? error : ""}
                {...field}
              />
            )}
          </Field>
          <Grid container spacing={2} direction="row" justify="flex-start" alignItems="flex-start">
            <Grid item>
              <Button
                type="submit"
                fullWidth
                variant="contained"
                color="primary"
                className={classes.submit}
                data-test="bankaccount-submit"
                disabled={!isValid || isSubmitting}
              >
                Save
              </Button>
            </Grid>
          </Grid>
        </Form>
      )}
    </Formik>
  );
};

export default BankAccountForm;



================================================
FILE: cypress-realworld-app/src/components/BankAccountItem.tsx
================================================
import React from "react";

import ListItem from "@material-ui/core/ListItem";
import { BankAccount } from "../models";
import { Grid, Typography, Button } from "@material-ui/core";

export interface BankAccountListItemProps {
  bankAccount: BankAccount;
  deleteBankAccount: Function;
}

const BankAccountListItem: React.FC<BankAccountListItemProps> = ({
  bankAccount,
  deleteBankAccount,
}) => {
  return (
    <ListItem data-test={`bankaccount-list-item-${bankAccount.id}`}>
      <Grid container direction="row" justify="space-between" alignItems="flex-start">
        <Grid item>
          <Typography variant="body1" color="primary" gutterBottom>
            {bankAccount.bankName} {bankAccount.isDeleted ? "(Deleted)" : undefined}
          </Typography>
        </Grid>
        {!bankAccount.isDeleted && (
          <Grid item>
            <Button
              variant="contained"
              color="secondary"
              size="large"
              data-test="bankaccount-delete"
              onClick={() => {
                deleteBankAccount({ id: bankAccount.id });
              }}
            >
              Delete
            </Button>
          </Grid>
        )}
      </Grid>
    </ListItem>
  );
};

export default BankAccountListItem;



================================================
FILE: cypress-realworld-app/src/components/BankAccountList.tsx
================================================
import React from "react";

import BankAccountItem from "./BankAccountItem";
import List from "@material-ui/core/List";
import { BankAccount } from "../models";
import EmptyList from "./EmptyList";

export interface BankAccountListProps {
  bankAccounts: BankAccount[];
  deleteBankAccount: Function;
}

const BankAccountList: React.FC<BankAccountListProps> = ({ bankAccounts, deleteBankAccount }) => {
  return (
    <>
      {bankAccounts?.length > 0 ? (
        <List data-test="bankaccount-list">
          {bankAccounts.map((bankAccount: BankAccount) => (
            <BankAccountItem
              key={bankAccount.id}
              bankAccount={bankAccount}
              deleteBankAccount={deleteBankAccount}
            />
          ))}
        </List>
      ) : (
        <EmptyList entity="Bank Accounts" />
      )}
    </>
  );
};

export default BankAccountList;



================================================
FILE: cypress-realworld-app/src/components/CommentForm.tsx
================================================
import React from "react";
import TextField from "@material-ui/core/TextField";
import { makeStyles } from "@material-ui/core/styles";
import { Formik, Form, Field, FieldProps } from "formik";
import { string, object } from "yup";

const validationSchema = object({
  content: string(),
});

const useStyles = makeStyles((theme) => ({
  paper: {
    marginTop: theme.spacing(8),
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  form: {
    width: "100%", // Fix IE 11 issue.
    marginTop: theme.spacing(1),
  },
}));

export interface CommentFormProps {
  transactionId: string;
  transactionComment: (payload: object) => void;
}

const CommentForm: React.FC<CommentFormProps> = ({ transactionId, transactionComment }) => {
  const classes = useStyles();
  const initialValues = { content: "" };

  return (
    <div>
      <Formik
        initialValues={initialValues}
        validationSchema={validationSchema}
        onSubmit={(values, { setSubmitting }) => {
          setSubmitting(true);
          transactionComment({ transactionId, ...values });
        }}
      >
        {() => (
          <Form className={classes.form}>
            <Field name="content">
              {({ field, meta }: FieldProps) => (
                <TextField
                  variant="outlined"
                  margin="dense"
                  fullWidth
                  id={`transaction-comment-input-${transactionId}`}
                  type="text"
                  placeholder="Write a comment..."
                  inputProps={{ "data-test": `transaction-comment-input-${transactionId}` }}
                  error={meta.touched && Boolean(meta.error)}
                  helperText={meta.touched ? meta.error : ""}
                  {...field}
                />
              )}
            </Field>
          </Form>
        )}
      </Formik>
    </div>
  );
};

export default CommentForm;



================================================
FILE: cypress-realworld-app/src/components/CommentList.tsx
================================================
import React from "react";

import CommentListItem from "./CommentListItem";
import List from "@material-ui/core/List";
import { Comment } from "../models";

export interface CommentsListProps {
  comments: Comment[];
}

const CommentsList: React.FC<CommentsListProps> = ({ comments }) => {
  return (
    <List data-test="comments-list">
      {comments &&
        comments.map((comment: Comment) => <CommentListItem key={comment.id} comment={comment} />)}
    </List>
  );
};

export default CommentsList;



================================================
FILE: cypress-realworld-app/src/components/CommentListItem.tsx
================================================
import React from "react";

import ListItem from "@material-ui/core/ListItem";
import { Comment } from "../models";
import { ListItemText } from "@material-ui/core";

export interface CommentListItemProps {
  comment: Comment;
}

const CommentListItem: React.FC<CommentListItemProps> = ({ comment }) => {
  return (
    <ListItem data-test={`comment-list-item-${comment.id}`}>
      <ListItemText primary={`${comment.content}`} />
    </ListItem>
  );
};

export default CommentListItem;



================================================
FILE: cypress-realworld-app/src/components/EmptyList.tsx
================================================
import React from "react";
import { Box, Typography, Grid } from "@material-ui/core";
import grey from "@material-ui/core/colors/grey";
const EmptyList: React.FC<{ entity: string; children?: React.ReactNode }> = ({
  entity,
  children,
}) => {
  return (
    <Box
      display="flex"
      height={600}
      min-height={600}
      alignItems="center"
      justifyContent="center"
      border={1}
      borderColor={grey[200]}
    >
      <Grid
        container
        direction="column"
        justify="center"
        alignItems="center"
        style={{ height: "100%", width: "100%" }}
        spacing={2}
      >
        <Grid item data-test="empty-list-header">
          <Typography component="h2" variant="h6" color="primary" gutterBottom>
            No {entity}
          </Typography>
        </Grid>
        <Grid item>
          <Box
            data-test="empty-list-children"
            display="flex"
            width={300}
            alignItems="center"
            justifyContent="center"
          >
            {children}
          </Box>
        </Grid>
      </Grid>
    </Box>
  );
};

export default EmptyList;



================================================
FILE: cypress-realworld-app/src/components/Footer.tsx
================================================
import React from "react";
import Typography from "@material-ui/core/Typography";
import { ReactComponent as CypressLogo } from "../svgs/cypress-logo.svg";
import { Container } from "@material-ui/core";

export default function Footer() {
  return (
    <Container maxWidth="sm" style={{ marginTop: 50 }}>
      <Typography variant="body2" color="textSecondary" align="center">
        Built by
        <a
          style={{ textDecoration: "none" }}
          target="_blank"
          rel="noopener noreferrer"
          href="https://cypress.io"
        >
          <CypressLogo
            style={{
              marginTop: -2,
              marginLeft: 5,
              height: "20px",
              width: "55px",
              verticalAlign: "middle",
            }}
          />
        </a>
      </Typography>
    </Container>
  );
}



================================================
FILE: cypress-realworld-app/src/components/MainLayout.tsx
================================================
import React, { useEffect } from "react";
import { useMachine } from "@xstate/react";
import { Interpreter } from "xstate";
import { makeStyles } from "@material-ui/core/styles";
import Container from "@material-ui/core/Container";
import Grid from "@material-ui/core/Grid";
import { useMediaQuery, useTheme } from "@material-ui/core";

import Footer from "./Footer";
import NavBar from "./NavBar";
import NavDrawer from "./NavDrawer";
import { DataContext, DataEvents } from "../machines/dataMachine";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";
import { drawerMachine } from "../machines/drawerMachine";

const useStyles = makeStyles((theme) => ({
  root: {
    display: "flex",
  },
  toolbar: {
    paddingRight: 24, // keep right padding when drawer closed
  },
  appBarSpacer: {
    minHeight: theme.spacing(13),
    [theme.breakpoints.up("sm")]: {
      minHeight: theme.spacing(14),
    },
  },
  content: {
    flexGrow: 1,
    height: "100vh",
    overflow: "auto",
  },
  container: {
    minHeight: "77vh",
    paddingTop: theme.spacing(1),
    paddingBottom: theme.spacing(1),
    [theme.breakpoints.up("sm")]: {
      paddingTop: theme.spacing(4),
      padding: theme.spacing(4),
    },
  },
}));

interface Props {
  children: React.ReactNode;
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
  notificationsService: Interpreter<DataContext, any, DataEvents, any>;
}

const MainLayout: React.FC<Props> = ({ children, notificationsService, authService }) => {
  const classes = useStyles();
  const theme = useTheme();
  const [drawerState, sendDrawer] = useMachine(drawerMachine);

  const aboveSmallBreakpoint = useMediaQuery(theme.breakpoints.up("sm"));
  const xsBreakpoint = useMediaQuery(theme.breakpoints.only("xs"));

  const desktopDrawerOpen = drawerState?.matches({ desktop: "open" });
  const mobileDrawerOpen = drawerState?.matches({ mobile: "open" });
  const toggleDesktopDrawer = () => {
    sendDrawer("TOGGLE_DESKTOP");
  };
  const toggleMobileDrawer = () => {
    sendDrawer("TOGGLE_MOBILE");
  };

  const openDesktopDrawer = (payload: any) => sendDrawer("OPEN_DESKTOP", payload);
  const closeMobileDrawer = () => sendDrawer("CLOSE_MOBILE");

  useEffect(() => {
    if (!desktopDrawerOpen && aboveSmallBreakpoint) {
      openDesktopDrawer({ aboveSmallBreakpoint });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [aboveSmallBreakpoint, desktopDrawerOpen]);

  return (
    <>
      <NavBar
        toggleDrawer={xsBreakpoint ? toggleMobileDrawer : toggleDesktopDrawer}
        drawerOpen={xsBreakpoint ? mobileDrawerOpen : desktopDrawerOpen}
        notificationsService={notificationsService}
      />
      <NavDrawer
        toggleDrawer={xsBreakpoint ? toggleMobileDrawer : toggleDesktopDrawer}
        drawerOpen={xsBreakpoint ? mobileDrawerOpen : desktopDrawerOpen}
        closeMobileDrawer={closeMobileDrawer}
        authService={authService}
      />
      <main className={classes.content} data-test="main">
        <div className={classes.appBarSpacer} />
        <Container maxWidth="md" className={classes.container}>
          <Grid container spacing={3}>
            <Grid item xs={12}>
              {children}
            </Grid>
          </Grid>
        </Container>
        <footer>
          <Footer />
        </footer>
      </main>
    </>
  );
};

export default MainLayout;



================================================
FILE: cypress-realworld-app/src/components/NavBar.tsx
================================================
import React from "react";
import clsx from "clsx";
import { makeStyles } from "@material-ui/core/styles";
import AppBar from "@material-ui/core/AppBar";
import Toolbar from "@material-ui/core/Toolbar";
import Typography from "@material-ui/core/Typography";
import IconButton from "@material-ui/core/IconButton";
import Badge from "@material-ui/core/Badge";
import MenuIcon from "@material-ui/icons/Menu";
import NotificationsIcon from "@material-ui/icons/Notifications";
import AttachMoneyIcon from "@material-ui/icons/AttachMoney";
import Link from "@material-ui/core/Link";
import { Link as RouterLink, useLocation } from "react-router-dom";
import { Button, useTheme, useMediaQuery } from "@material-ui/core";
import { Interpreter } from "xstate";
import { DataContext, DataEvents } from "../machines/dataMachine";
import { useService } from "@xstate/react";
import TransactionNavTabs from "./TransactionNavTabs";
import { ReactComponent as RWALogo } from "../svgs/rwa-logo.svg";
import { ReactComponent as RWALogoIcon } from "../svgs/rwa-icon-logo.svg";

const drawerWidth = 240;

const useStyles = makeStyles((theme) => ({
  toolbar: {
    paddingRight: 24, // keep right padding when drawer closed
  },
  appBar: {
    zIndex: theme.zIndex.drawer + 1,
    transition: theme.transitions.create(["width", "margin"], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen,
    }),
  },
  appBarShift: {
    marginLeft: drawerWidth,
    width: `calc(100% - ${drawerWidth}px)`,
    transition: theme.transitions.create(["width", "margin"], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.enteringScreen,
    }),
  },
  menuButtonHidden: {
    display: "none",
  },
  title: {
    flexGrow: 1,
    textAlign: "center",
  },
  logo: {
    color: "white",
    verticalAlign: "bottom",
  },
  newTransactionButton: {
    fontSize: 16,
    backgroundColor: "#00C853",
    paddingTop: 5,
    paddingBottom: 5,
    paddingRight: 20,
    fontWeight: "bold",
    "&:hover": {
      backgroundColor: "#4CAF50",
      borderColor: "#00C853",
      boxShadow: "none",
    },
  },
  customBadge: {
    backgroundColor: "red",
    color: "white",
  },
}));

interface NavBarProps {
  drawerOpen: boolean;
  toggleDrawer: Function;
  notificationsService: Interpreter<DataContext, any, DataEvents, any>;
}

const NavBar: React.FC<NavBarProps> = ({ drawerOpen, toggleDrawer, notificationsService }) => {
  const match = useLocation();
  const classes = useStyles();
  const theme = useTheme();
  const [notificationsState] = useService(notificationsService);

  const allNotifications = notificationsState?.context?.results;
  const xsBreakpoint = useMediaQuery(theme.breakpoints.only("xs"));

  return (
    <AppBar position="absolute" className={clsx(classes.appBar, drawerOpen && classes.appBarShift)}>
      <Toolbar className={classes.toolbar}>
        <IconButton
          data-test="sidenav-toggle"
          edge="start"
          color="inherit"
          aria-label="open drawer"
          onClick={() => toggleDrawer()}
        >
          <MenuIcon data-test="drawer-icon" />
        </IconButton>
        <Typography
          component="h1"
          variant="h6"
          color="inherit"
          noWrap
          className={classes.title}
          data-test="app-name-logo"
        >
          <Link to="/" style={{ color: "#fff", textDecoration: "none" }} component={RouterLink}>
            {xsBreakpoint ? (
              <RWALogoIcon className={classes.logo} />
            ) : (
              <RWALogo className={classes.logo} />
            )}
          </Link>
        </Typography>
        <Button
          className={classes.newTransactionButton}
          variant="contained"
          color="inherit"
          component={RouterLink}
          to="/transaction/new"
          data-test="nav-top-new-transaction"
        >
          <AttachMoneyIcon /> New
        </Button>
        <IconButton
          color="inherit"
          component={RouterLink}
          to="/notifications"
          data-test="nav-top-notifications-link"
        >
          <Badge
            badgeContent={allNotifications ? allNotifications.length : undefined}
            data-test="nav-top-notifications-count"
            classes={{ badge: classes.customBadge }}
          >
            <NotificationsIcon />
          </Badge>
        </IconButton>
      </Toolbar>
      {(match.pathname === "/" || RegExp("/(?:public|contacts|personal)").test(match.pathname)) && (
        <TransactionNavTabs />
      )}
    </AppBar>
  );
};

export default NavBar;



================================================
FILE: cypress-realworld-app/src/components/NavDrawer.tsx
================================================
import React from "react";
import { head } from "lodash/fp";
import { Interpreter } from "xstate";
import { useService } from "@xstate/react";
import clsx from "clsx";
import { useMediaQuery, useTheme } from "@material-ui/core";
import { Link as RouterLink } from "react-router-dom";
import { makeStyles } from "@material-ui/core/styles";
import Drawer from "@material-ui/core/Drawer";
import List from "@material-ui/core/List";
import Divider from "@material-ui/core/Divider";
import ListItem from "@material-ui/core/ListItem";
import ListItemIcon from "@material-ui/core/ListItemIcon";
import ListItemText from "@material-ui/core/ListItemText";
import HomeIcon from "@material-ui/icons/Home";
import PersonIcon from "@material-ui/icons/Person";
import LogoutIcon from "@material-ui/icons/ExitToApp";
import NotificationsIcon from "@material-ui/icons/Notifications";
import AccountBalanceIcon from "@material-ui/icons/AccountBalance";
import { Grid, Avatar, Typography } from "@material-ui/core";
import { formatAmount } from "../utils/transactionUtils";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";

const drawerWidth = 240;

export const mainListItems = (
  toggleDrawer: ((event: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => void) | undefined,
  showTemporaryDrawer: Boolean
) => (
  <div>
    <ListItem
      button
      // @ts-ignore
      onClick={() => showTemporaryDrawer && toggleDrawer()}
      component={RouterLink}
      to="/"
      data-test="sidenav-home"
    >
      <ListItemIcon>
        <HomeIcon />
      </ListItemIcon>
      <ListItemText primary="Home" />
    </ListItem>
    <ListItem
      button
      // @ts-ignore
      onClick={() => showTemporaryDrawer && toggleDrawer()}
      component={RouterLink}
      to="/user/settings"
      data-test="sidenav-user-settings"
    >
      <ListItemIcon>
        <PersonIcon />
      </ListItemIcon>
      <ListItemText primary="My Account" />
    </ListItem>
    <ListItem
      button
      // @ts-ignore
      onClick={() => showTemporaryDrawer && toggleDrawer()}
      component={RouterLink}
      to="/bankaccounts"
      data-test="sidenav-bankaccounts"
    >
      <ListItemIcon>
        <AccountBalanceIcon />
      </ListItemIcon>
      <ListItemText primary="Bank Accounts" />
    </ListItem>
    <ListItem
      button
      // @ts-ignore
      onClick={() => showTemporaryDrawer && toggleDrawer()}
      component={RouterLink}
      to="/notifications"
      data-test="sidenav-notifications"
    >
      <ListItemIcon>
        <NotificationsIcon />
      </ListItemIcon>
      <ListItemText primary="Notifications" />
    </ListItem>
  </div>
);

export const secondaryListItems = (signOutPending: Function) => (
  <div>
    <ListItem button onClick={() => signOutPending()} data-test="sidenav-signout">
      <ListItemIcon>
        <LogoutIcon />
      </ListItemIcon>
      <ListItemText primary="Logout" />
    </ListItem>
  </div>
);

const useStyles = makeStyles((theme) => ({
  toolbar: {
    paddingRight: 24, // keep right padding when drawer closed
  },
  toolbarIcon: {
    display: "flex",
    alignItems: "center",
    justifyContent: "flex-end",
    padding: "0 8px",
    ...theme.mixins.toolbar,
  },
  drawerPaper: {
    position: "relative",
    whiteSpace: "nowrap",
    width: drawerWidth,
    transition: theme.transitions.create("width", {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.enteringScreen,
    }),
  },
  drawerPaperClose: {
    marginTop: 50,
    overflowX: "hidden",
    transition: theme.transitions.create("width", {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen,
    }),
    width: theme.spacing(7),
    [theme.breakpoints.up("sm")]: {
      width: theme.spacing(9),
    },
  },
  userProfile: {
    padding: theme.spacing(2),
  },
  userProfileHidden: {
    display: "none",
  },
  avatar: {
    marginRight: theme.spacing(2),
  },
  accountBalance: {
    marginLeft: theme.spacing(2),
  },
  amount: {
    fontWeight: "bold",
  },
  accountBalanceHidden: {
    display: "none",
  },
  cypressLogo: {
    width: "40%",
  },
}));

interface Props {
  closeMobileDrawer: () => void;
  toggleDrawer: () => void;
  drawerOpen: boolean;
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
}

const NavDrawer: React.FC<Props> = ({
  toggleDrawer,
  closeMobileDrawer,
  drawerOpen,
  authService,
}) => {
  const classes = useStyles();
  const theme = useTheme();
  const [authState, sendAuth] = useService(authService);
  const showTemporaryDrawer = useMediaQuery(theme.breakpoints.only("xs"));

  const currentUser = authState?.context?.user;
  const signOut = () => sendAuth("LOGOUT");

  return (
    <Drawer
      data-test="sidenav"
      variant={showTemporaryDrawer ? "temporary" : "persistent"}
      classes={{
        paper: clsx(classes.drawerPaper, !drawerOpen && classes.drawerPaperClose),
      }}
      open={drawerOpen}
      ModalProps={{
        onBackdropClick: () => closeMobileDrawer(),
        closeAfterTransition: showTemporaryDrawer,
      }}
    >
      <Grid
        container
        direction="row"
        justify="space-between"
        alignItems="center"
        className={drawerOpen ? classes.userProfile : classes.userProfileHidden}
      >
        <Grid item>
          {currentUser && (
            <Avatar
              className={classes.avatar}
              alt={`${currentUser.firstName} ${currentUser.lastName}`}
              src={currentUser.avatar}
            />
          )}
        </Grid>
        <Grid item>
          {currentUser && (
            <>
              <Typography
                variant="subtitle1"
                color="textPrimary"
                data-test="sidenav-user-full-name"
              >
                {currentUser.firstName} {head(currentUser.lastName)}
              </Typography>
              <Typography
                variant="subtitle2"
                color="inherit"
                gutterBottom
                data-test="sidenav-username"
              >
                @{currentUser.username}
              </Typography>
            </>
          )}
        </Grid>
        <Grid item style={{ width: "30%" }}></Grid>
      </Grid>
      <Grid
        container
        direction="row"
        justify="space-between"
        alignItems="center"
        className={drawerOpen ? classes.userProfile : classes.userProfileHidden}
      >
        <Grid item>
          {currentUser && (
            <>
              <Typography
                variant="h6"
                color="textPrimary"
                className={classes.amount}
                data-test="sidenav-user-balance"
              >
                {formatAmount(currentUser.balance)}
              </Typography>
              <Typography variant="subtitle2" color="inherit" gutterBottom>
                Account Balance
              </Typography>
            </>
          )}
        </Grid>
        <Grid item>
          <Divider />
        </Grid>
        <Grid item>
          <List>{mainListItems(toggleDrawer, showTemporaryDrawer)}</List>
        </Grid>
        <Grid item>
          <Divider />
        </Grid>
        <Grid item>
          <List>{secondaryListItems(signOut)}</List>
        </Grid>
      </Grid>
    </Drawer>
  );
};

export default NavDrawer;



================================================
FILE: cypress-realworld-app/src/components/NotificationList.tsx
================================================
import React from "react";

import NotificationListItem from "./NotificationListItem";
import List from "@material-ui/core/List";
import { NotificationResponseItem } from "../models";
import EmptyList from "./EmptyList";
import { ReactComponent as RemindersIllustration } from "../svgs/undraw_reminders_697p.svg";

export interface NotificationsListProps {
  notifications: NotificationResponseItem[];
  updateNotification: Function;
}

const NotificationsList: React.FC<NotificationsListProps> = ({
  notifications,
  updateNotification,
}) => {
  return (
    <>
      {notifications?.length > 0 ? (
        <List data-test="notifications-list">
          {notifications.map((notification: NotificationResponseItem) => (
            <NotificationListItem
              key={notification.id}
              notification={notification}
              updateNotification={updateNotification}
            />
          ))}
        </List>
      ) : (
        <EmptyList entity="Notifications">
          <RemindersIllustration style={{ height: 200, width: 250, marginBottom: 30 }} />
        </EmptyList>
      )}
    </>
  );
};

export default NotificationsList;



================================================
FILE: cypress-realworld-app/src/components/NotificationListItem.tsx
================================================
import React from "react";

import ListItem from "@material-ui/core/ListItem";
import LikeIcon from "@material-ui/icons/ThumbUpAltOutlined";
import PaymentIcon from "@material-ui/icons/Payment";
import CommentIcon from "@material-ui/icons/CommentRounded";
import IconButton from "@material-ui/core/IconButton";
import CheckIcon from "@material-ui/icons/Check";
import MonetizationOnIcon from "@material-ui/icons/MonetizationOn";
import { NotificationResponseItem } from "../models";
import {
  Button,
  makeStyles,
  ListItemIcon,
  ListItemText,
  useTheme,
  useMediaQuery,
} from "@material-ui/core";
import {
  isCommentNotification,
  isLikeNotification,
  isPaymentNotification,
  isPaymentRequestedNotification,
  isPaymentReceivedNotification,
} from "../utils/transactionUtils";

export interface NotificationListItemProps {
  notification: NotificationResponseItem;
  updateNotification: Function;
}

const useStyles = makeStyles({
  card: {
    minWidth: "100%",
  },
  title: {
    fontSize: 18,
  },
  green: {
    color: "#4CAF50",
  },
  red: {
    color: "red",
  },
  blue: {
    color: "blue",
  },
});

const NotificationListItem: React.FC<NotificationListItemProps> = ({
  notification,
  updateNotification,
}) => {
  const classes = useStyles();
  const theme = useTheme();
  let listItemText = undefined;
  let listItemIcon = undefined;
  const xsBreakpoint = useMediaQuery(theme.breakpoints.only("xs"));

  if (isCommentNotification(notification)) {
    listItemIcon = <CommentIcon />;
    listItemText = `${notification.userFullName} commented on a transaction.`;
  }

  if (isLikeNotification(notification)) {
    listItemIcon = <LikeIcon />;
    listItemText = `${notification.userFullName} liked a transaction.`;
  }

  if (isPaymentNotification(notification)) {
    if (isPaymentRequestedNotification(notification)) {
      listItemIcon = <PaymentIcon className={classes.red} />;
      listItemText = `${notification.userFullName} requested payment.`;
    } else if (isPaymentReceivedNotification(notification)) {
      listItemIcon = <MonetizationOnIcon className={classes.green} />;
      listItemText = `${notification.userFullName} received payment.`;
    }
  }

  return (
    <ListItem data-test={`notification-list-item-${notification.id}`}>
      <ListItemIcon>{listItemIcon!}</ListItemIcon>
      <ListItemText primary={listItemText} />
      {xsBreakpoint && (
        <IconButton
          aria-label="mark as read"
          color="primary"
          onClick={() => updateNotification({ id: notification.id, isRead: true })}
          data-test={`notification-mark-read-${notification.id}`}
        >
          <CheckIcon />
        </IconButton>
      )}
      {!xsBreakpoint && (
        <Button
          color="primary"
          size="small"
          onClick={() => updateNotification({ id: notification.id, isRead: true })}
          data-test={`notification-mark-read-${notification.id}`}
        >
          Dismiss
        </Button>
      )}
    </ListItem>
  );
};

export default NotificationListItem;



================================================
FILE: cypress-realworld-app/src/components/PrivateRoute.tsx
================================================
import React from "react";
import { Route, Redirect, RouteProps } from "react-router-dom";

interface IPrivateRouteProps extends RouteProps {
  isLoggedIn: boolean;
}

function PrivateRoute({ isLoggedIn, children, ...rest }: IPrivateRouteProps) {
  return (
    <Route
      {...rest}
      render={({ location }) =>
        isLoggedIn ? (
          children
        ) : (
          /* istanbul ignore next */
          <Redirect
            to={{
              pathname: "/signin",
              state: { from: location },
            }}
          />
        )
      }
    />
  );
}

export default PrivateRoute;



================================================
FILE: cypress-realworld-app/src/components/SignInForm.tsx
================================================
import React from "react";
import { Interpreter } from "xstate";
import { useService } from "@xstate/react";
import { Link } from "react-router-dom";
import Button from "@material-ui/core/Button";
import CssBaseline from "@material-ui/core/CssBaseline";
import TextField from "@material-ui/core/TextField";
import FormControlLabel from "@material-ui/core/FormControlLabel";
import Checkbox from "@material-ui/core/Checkbox";
import Grid from "@material-ui/core/Grid";
import Box from "@material-ui/core/Box";
import Typography from "@material-ui/core/Typography";
import { makeStyles } from "@material-ui/core/styles";
import Container from "@material-ui/core/Container";
import { Formik, Form, Field, FieldProps } from "formik";
import { string, object } from "yup";

import { ReactComponent as RWALogo } from "../svgs/rwa-logo.svg";
import Footer from "./Footer";
import { SignInPayload } from "../models";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";
import Alert from "@material-ui/lab/Alert";

const validationSchema = object({
  username: string().required("Username is required"),
  password: string()
    .min(4, "Password must contain at least 4 characters")
    .required("Enter your password"),
});

const useStyles = makeStyles((theme) => ({
  paper: {
    marginTop: theme.spacing(8),
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  logo: {
    color: theme.palette.primary.main,
  },
  form: {
    width: "100%", // Fix IE 11 issue.
    marginTop: theme.spacing(1),
  },
  submit: {
    margin: theme.spacing(3, 0, 2),
  },
  alertMessage: {
    marginBottom: theme.spacing(2),
  },
}));

export interface Props {
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
}

const SignInForm: React.FC<Props> = ({ authService }) => {
  const classes = useStyles();
  const [authState, sendAuth] = useService(authService);
  const initialValues: SignInPayload = {
    username: "",
    password: "",
    remember: undefined,
  };

  const signInPending = (payload: SignInPayload) => sendAuth("LOGIN", payload);

  return (
    <Container component="main" maxWidth="xs">
      <CssBaseline />
      <div className={classes.paper}>
        {authState.context?.message && (
          <Alert data-test="signin-error" severity="error" className={classes.alertMessage}>
            {authState.context.message}
          </Alert>
        )}
        <div>
          <RWALogo className={classes.logo} />
        </div>
        <Typography component="h1" variant="h5">
          Sign in
        </Typography>
        <Formik
          initialValues={initialValues}
          validationSchema={validationSchema}
          onSubmit={async (values, { setSubmitting }) => {
            setSubmitting(true);

            signInPending(values);
          }}
        >
          {({ isValid, isSubmitting }) => (
            <Form className={classes.form}>
              <Field name="username">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="normal"
                    fullWidth
                    id="username"
                    label="Username"
                    type="text"
                    autoFocus
                    data-test="signin-username"
                    error={(touched || value !== initialValue) && Boolean(error)}
                    helperText={touched || value !== initialValue ? error : ""}
                    {...field}
                  />
                )}
              </Field>
              <Field name="password">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="normal"
                    fullWidth
                    label="Password"
                    type="password"
                    id="password"
                    data-test="signin-password"
                    error={touched && value !== initialValue && Boolean(error)}
                    helperText={touched && value !== initialValue && touched ? error : ""}
                    {...field}
                  />
                )}
              </Field>
              <FormControlLabel
                control={
                  <Field name={"remember"}>
                    {({ field }: FieldProps) => {
                      return <Checkbox color="primary" data-test="signin-remember-me" {...field} />;
                    }}
                  </Field>
                }
                label="Remember me"
              />
              <Button
                type="submit"
                fullWidth
                variant="contained"
                color="primary"
                className={classes.submit}
                data-test="signin-submit"
                disabled={!isValid || isSubmitting}
              >
                Sign In
              </Button>
              <Grid container>
                <Grid item xs>
                  {/*<Link to="/forgotpassword">Forgot password?</Link>*/}
                </Grid>
                <Grid item>
                  <Link data-test="signup" to="/signup">
                    {"Don't have an account? Sign Up"}
                  </Link>
                </Grid>
              </Grid>
            </Form>
          )}
        </Formik>
      </div>
      <Box mt={8}>
        <Footer />
      </Box>
    </Container>
  );
};

export default SignInForm;



================================================
FILE: cypress-realworld-app/src/components/SignUpForm.tsx
================================================
import React from "react";
import { useService } from "@xstate/react";
import { Interpreter } from "xstate";
import { Link } from "react-router-dom";
import Button from "@material-ui/core/Button";
import CssBaseline from "@material-ui/core/CssBaseline";
import TextField from "@material-ui/core/TextField";
import Grid from "@material-ui/core/Grid";
import Box from "@material-ui/core/Box";
import Typography from "@material-ui/core/Typography";
import { makeStyles } from "@material-ui/core/styles";
import Container from "@material-ui/core/Container";
import { Formik, Form, Field, FieldProps } from "formik";
import { string, object, ref } from "yup";

import { ReactComponent as RWALogo } from "../svgs/rwa-logo.svg";
import Footer from "./Footer";
import { SignUpPayload } from "../models";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";

const validationSchema = object({
  firstName: string().required("First Name is required"),
  lastName: string().required("Last Name is required"),
  username: string().required("Username is required"),
  password: string()
    .min(4, "Password must contain at least 4 characters")
    .required("Enter your password"),
  confirmPassword: string()
    .required("Confirm your password")
    .oneOf([ref("password")], "Password does not match"),
});

const useStyles = makeStyles((theme) => ({
  paper: {
    marginTop: theme.spacing(8),
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  logo: {
    color: theme.palette.primary.main,
  },
  form: {
    width: "100%", // Fix IE 11 issue.
    marginTop: theme.spacing(1),
  },
  submit: {
    margin: theme.spacing(3, 0, 2),
  },
}));

export interface Props {
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
}

const SignUpForm: React.FC<Props> = ({ authService }) => {
  const classes = useStyles();
  const [, sendAuth] = useService(authService);
  const initialValues: SignUpPayload & { confirmPassword: string } = {
    firstName: "",
    lastName: "",
    username: "",
    password: "",
    confirmPassword: "",
  };

  const signUpPending = (payload: SignUpPayload) => sendAuth("SIGNUP", payload);

  return (
    <Container component="main" maxWidth="xs">
      <CssBaseline />
      <div className={classes.paper}>
        <div>
          <RWALogo className={classes.logo} />
        </div>
        <Typography component="h1" variant="h5" data-test="signup-title">
          Sign Up
        </Typography>
        <Formik
          initialValues={initialValues}
          validationSchema={validationSchema}
          onSubmit={async (values, { setSubmitting, setFieldValue }) => {
            setSubmitting(true);

            signUpPending(values);
          }}
        >
          {({ isValid, isSubmitting, dirty }) => (
            <Form className={classes.form}>
              <Field name="firstName">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="normal"
                    required
                    fullWidth
                    id="firstName"
                    label="First Name"
                    type="text"
                    autoFocus
                    data-test="signup-first-name"
                    error={(touched || value !== initialValue) && Boolean(error)}
                    helperText={touched || value !== initialValue ? error : ""}
                    {...field}
                  />
                )}
              </Field>
              <Field name="lastName">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="normal"
                    required
                    fullWidth
                    id="lastName"
                    label="Last Name"
                    type="text"
                    data-test="signup-last-name"
                    error={(touched || value !== initialValue) && Boolean(error)}
                    helperText={touched || value !== initialValue ? error : ""}
                    {...field}
                  />
                )}
              </Field>
              <Field name="username">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="normal"
                    required
                    fullWidth
                    id="username"
                    label="Username"
                    type="text"
                    data-test="signup-username"
                    error={(touched || value !== initialValue) && Boolean(error)}
                    helperText={touched || value !== initialValue ? error : ""}
                    {...field}
                  />
                )}
              </Field>
              <Field name="password">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="normal"
                    required
                    fullWidth
                    label="Password"
                    type="password"
                    id="password"
                    data-test="signup-password"
                    error={(touched || value !== initialValue) && Boolean(error)}
                    helperText={touched || value !== initialValue ? error : ""}
                    {...field}
                  />
                )}
              </Field>
              <Field name="confirmPassword">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="normal"
                    required
                    fullWidth
                    label="Confirm Password"
                    id="confirmPassword"
                    data-test="signup-confirmPassword"
                    type="password"
                    error={(touched || value !== initialValue) && Boolean(error)}
                    helperText={touched || value !== initialValue ? error : ""}
                    {...field}
                  />
                )}
              </Field>
              <Button
                type="submit"
                fullWidth
                variant="contained"
                color="primary"
                className={classes.submit}
                data-test="signup-submit"
                disabled={!isValid || isSubmitting}
              >
                Sign Up
              </Button>
              <Grid container>
                <Grid item>
                  <Link to="/signin">{"Have an account? Sign In"}</Link>
                </Grid>
              </Grid>
            </Form>
          )}
        </Formik>
      </div>
      <Box mt={8}>
        <Footer />
      </Box>
    </Container>
  );
};

export default SignUpForm;



================================================
FILE: cypress-realworld-app/src/components/SkeletonList.tsx
================================================
import React from "react";
import Skeleton from "@material-ui/lab/Skeleton";
import { makeStyles } from "@material-ui/core/styles";

const useStyles = makeStyles((theme) => ({
  root: {
    minHeight: "100vh",
    marginLeft: theme.spacing(2),
    marginRight: theme.spacing(2),
    width: "95%",
  },
}));

const ListSkeleton = () => {
  const classes = useStyles();
  return (
    <div className={classes.root} data-test="list-skeleton">
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
      <br />
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
      <br />
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
      <br />
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
      <br />
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
      <br />
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
      <br />
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
      <br />
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
      <br />
      <br />
      <Skeleton />
      <Skeleton animation={false} />
      <Skeleton animation="wave" />
    </div>
  );
};

export default ListSkeleton;



================================================
FILE: cypress-realworld-app/src/components/TransactionAmount.tsx
================================================
import React from "react";
import { makeStyles } from "@material-ui/core/styles";
import { TransactionResponseItem } from "../models";
import { Typography } from "@material-ui/core";
import { isRequestTransaction, formatAmount } from "../utils/transactionUtils";

const useStyles = makeStyles((theme) => ({
  amountPositive: {
    fontSize: 24,
    [theme.breakpoints.down("sm")]: {
      fontSize: theme.typography.body1.fontSize,
    },
    color: "#4CAF50",
  },
  amountNegative: {
    fontSize: 24,
    [theme.breakpoints.down("sm")]: {
      fontSize: theme.typography.body1.fontSize,
    },
    color: "red",
  },
}));

const TransactionAmount: React.FC<{
  transaction: TransactionResponseItem;
}> = ({ transaction }) => {
  const classes = useStyles();

  return (
    <Typography
      data-test={`transaction-amount-${transaction.id}`}
      className={
        isRequestTransaction(transaction) ? classes.amountPositive : classes.amountNegative
      }
      display="inline"
      component="span"
      color="primary"
    >
      {isRequestTransaction(transaction) ? "+" : "-"}
      {transaction.amount && formatAmount(transaction.amount)}
    </Typography>
  );
};

export default TransactionAmount;



================================================
FILE: cypress-realworld-app/src/components/TransactionContactsList.tsx
================================================
import React, { useEffect, ReactNode } from "react";
import { useMachine } from "@xstate/react";
import {
  TransactionPagination,
  TransactionResponseItem,
  TransactionDateRangePayload,
  TransactionAmountRangePayload,
} from "../models";
import TransactionList from "./TransactionList";
import { contactsTransactionsMachine } from "../machines/contactsTransactionsMachine";

export interface TransactionContactListProps {
  filterComponent: ReactNode;
  dateRangeFilters: TransactionDateRangePayload;
  amountRangeFilters: TransactionAmountRangePayload;
}

const TransactionContactsList: React.FC<TransactionContactListProps> = ({
  filterComponent,
  dateRangeFilters,
  amountRangeFilters,
}) => {
  const [current, send, contactTransactionService] = useMachine(contactsTransactionsMachine);
  const { pageData, results } = current.context;

  // @ts-ignore
  if (window.Cypress) {
    // @ts-ignore
    window.contactTransactionService = contactTransactionService;
  }

  useEffect(() => {
    send("FETCH", { ...dateRangeFilters, ...amountRangeFilters });
  }, [send, dateRangeFilters, amountRangeFilters]);

  const loadNextPage = (page: number) =>
    send("FETCH", { page, ...dateRangeFilters, ...amountRangeFilters });

  return (
    <>
      <TransactionList
        filterComponent={filterComponent}
        header="Contacts"
        transactions={results as TransactionResponseItem[]}
        isLoading={current.matches("loading")}
        loadNextPage={loadNextPage}
        pagination={pageData as TransactionPagination}
        showCreateButton
      />
    </>
  );
};

export default TransactionContactsList;



================================================
FILE: cypress-realworld-app/src/components/TransactionCreateStepOne.tsx
================================================
import React from "react";
import { makeStyles, Paper } from "@material-ui/core";
import UsersList from "./UsersList";
import { User } from "../models";
import UserListSearchForm from "./UserListSearchForm";

const useStyles = makeStyles((theme) => ({
  paper: {
    //marginTop: theme.spacing(2),
    padding: theme.spacing(2),
    display: "flex",
    overflow: "auto",
    flexDirection: "column",
  },
}));

export interface TransactionCreateStepOneProps {
  setReceiver: Function;
  userListSearch: Function;
  users: User[];
}

const TransactionCreateStepOne: React.FC<TransactionCreateStepOneProps> = ({
  setReceiver,
  userListSearch,
  users,
}) => {
  const classes = useStyles();

  return (
    <Paper className={classes.paper} elevation={0}>
      <UserListSearchForm userListSearch={userListSearch} />
      <UsersList users={users} setReceiver={setReceiver} />
    </Paper>
  );
};

export default TransactionCreateStepOne;



================================================
FILE: cypress-realworld-app/src/components/TransactionCreateStepThree.tsx
================================================
import React from "react";
import { Link as RouterLink, useHistory } from "react-router-dom";
import { makeStyles } from "@material-ui/core/styles";
import { Paper, Typography, Grid, Avatar, Box, Button } from "@material-ui/core";
import { Interpreter } from "xstate";
import {
  CreateTransactionMachineContext,
  CreateTransactionMachineEvents,
} from "../machines/createTransactionMachine";
import { useService } from "@xstate/react";
import { formatAmount } from "../utils/transactionUtils";

const useStyles = makeStyles((theme) => ({
  paper: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
}));

export interface TransactionCreateStepThreeProps {
  createTransactionService: Interpreter<
    CreateTransactionMachineContext,
    any,
    CreateTransactionMachineEvents,
    any
  >;
}

const TransactionCreateStepThree: React.FC<TransactionCreateStepThreeProps> = ({
  createTransactionService,
}) => {
  const history = useHistory();
  const classes = useStyles();
  const [createTransactionState, sendCreateTransaction] = useService(createTransactionService);

  const receiver = createTransactionState?.context?.receiver;
  const transactionDetails = createTransactionState?.context?.transactionDetails;

  return (
    <Paper className={classes.paper} elevation={0}>
      <Box
        display="flex"
        justifyContent="center"
        width="95%"
        min-height={200}
        height={200}
        style={{ paddingTop: "5%" }}
      >
        <Grid container direction="row" justify="space-around" alignItems="center" spacing={4}>
          <Grid item>
            <Grid container direction="column" justify="flex-start" alignItems="center">
              <Grid item>
                <Avatar src={receiver.avatar} />
              </Grid>
              <Grid item>
                <Typography component="h2" variant="h6" color="primary" gutterBottom>
                  {receiver.firstName} {receiver.lastName}
                </Typography>
              </Grid>
            </Grid>
          </Grid>
        </Grid>
      </Box>
      <Box
        display="flex"
        justifyContent="center"
        width="100%"
        height="100"
        style={{ paddingBottom: "5%" }}
      >
        <Grid container direction="row" justify="center" alignItems="center">
          <Grid item>
            <Typography component="h2" variant="h6" color="primary" gutterBottom>
              {transactionDetails?.transactionType === "payment" ? "Paid " : "Requested "}
              {transactionDetails?.amount &&
                formatAmount(parseInt(transactionDetails.amount, 10) * 100)}{" "}
              for {transactionDetails?.description}
            </Typography>
          </Grid>
        </Grid>
      </Box>
      <Box
        display="flex"
        justifyContent="center"
        width="100%"
        height="100"
        style={{ paddingBottom: "5%" }}
      >
        <Grid container direction="row" justify="space-around" alignItems="center">
          <Grid item>
            <Button
              variant="contained"
              size="small"
              component={RouterLink}
              to="/"
              data-test="new-transaction-return-to-transactions"
            >
              Return To Transactions
            </Button>
          </Grid>
          <Grid item>
            <Button
              variant="contained"
              size="small"
              /* istanbul ignore next */
              onClick={() => {
                sendCreateTransaction("RESET");
                history.push("/transaction/new");
              }}
              data-test="new-transaction-create-another-transaction"
            >
              Create Another Transaction
            </Button>
          </Grid>
        </Grid>
      </Box>
    </Paper>
  );
};

export default TransactionCreateStepThree;



================================================
FILE: cypress-realworld-app/src/components/TransactionCreateStepTwo.tsx
================================================
import React, { useState } from "react";
import NumberFormat from "react-number-format";
import TextField from "@material-ui/core/TextField";
import { makeStyles } from "@material-ui/core/styles";
import { Formik, Form, Field, FieldProps } from "formik";
import { string, object, number } from "yup";
import { Paper, Typography, Button, Grid, Container, Avatar, Box } from "@material-ui/core";
import { User } from "../models";

const validationSchema = object({
  amount: number().required("Please enter a valid amount"),
  description: string().required("Please enter a note"),
  senderId: string(),
  receiverId: string(),
});

const useStyles = makeStyles((theme) => ({
  paper: {
    //marginTop: theme.spacing(2),
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  form: {
    width: "100%", // Fix IE 11 issue.
    marginTop: theme.spacing(1),
  },
  submit: {
    margin: theme.spacing(3, 0, 2),
  },
}));

interface NumberFormatCustomProps {
  inputRef: (instance: NumberFormat | null) => void;
  onChange: (event: { target: { value: string } }) => void;
}

function NumberFormatCustom(props: NumberFormatCustomProps) {
  const { inputRef, onChange, ...other } = props;

  return (
    <NumberFormat
      {...other}
      getInputRef={inputRef}
      onValueChange={(values) => {
        onChange({
          target: {
            ...other,
            value: values.value,
          },
        });
      }}
      thousandSeparator
      isNumericString
      prefix="$"
    />
  );
}

export interface TransactionCreateStepTwoProps {
  receiver: User;
  sender: User;
  createTransaction: Function;
  showSnackbar: Function;
}

interface FormValues {
  amount: number | "";
  description: string;
  senderId: string;
  receiverId: string;
}

const TransactionCreateStepTwo: React.FC<TransactionCreateStepTwoProps> = ({
  receiver,
  sender,
  createTransaction,
  showSnackbar,
}) => {
  const classes = useStyles();
  const [transactionType, setTransactionType] = useState<string>();
  const initialValues: FormValues = {
    amount: "",
    description: "",
    senderId: sender.id,
    receiverId: receiver.id,
  };

  return (
    <Paper className={classes.paper} elevation={0}>
      <Box display="flex" height={200} alignItems="center" justifyContent="center">
        <Grid container direction="column" justify="flex-start" alignItems="center">
          <Grid item>
            <Avatar src={receiver.avatar} />
          </Grid>
          <Grid item>
            <Typography component="h2" variant="h6" color="primary" gutterBottom>
              {receiver.firstName} {receiver.lastName}
              {transactionType}
            </Typography>
          </Grid>
        </Grid>
      </Box>
      <Container maxWidth="xs">
        <Formik
          initialValues={initialValues}
          validationSchema={validationSchema}
          validateOnMount={true}
          onSubmit={(values, { setSubmitting }) => {
            setSubmitting(true);

            // reset transactionType
            setTransactionType(undefined);

            createTransaction({ transactionType, ...values });
            showSnackbar({
              severity: "success",
              message: "Transaction Submitted!",
            });
          }}
        >
          {({ isValid, isSubmitting }) => (
            <Form className={classes.form} data-test="transaction-create-form">
              <Field name="amount">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="dense"
                    fullWidth
                    required
                    autoFocus
                    id={"transaction-create-amount-input"}
                    type="text"
                    placeholder="Amount"
                    data-test={"transaction-create-amount-input"}
                    error={(touched || value !== initialValue) && Boolean(error)}
                    helperText={touched || value !== initialValue ? error : ""}
                    InputProps={{
                      inputComponent: NumberFormatCustom as any,
                      inputProps: { id: "amount" },
                    }}
                    {...field}
                  />
                )}
              </Field>
              <Field name="description">
                {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
                  <TextField
                    variant="outlined"
                    margin="dense"
                    fullWidth
                    required
                    id={"transaction-create-description-input"}
                    type="text"
                    placeholder="Add a note"
                    data-test={"transaction-create-description-input"}
                    error={(touched || value !== initialValue) && Boolean(error)}
                    helperText={touched || value !== initialValue ? error : ""}
                    {...field}
                  />
                )}
              </Field>
              <Grid container spacing={2} direction="row" justify="center" alignItems="center">
                <Grid item>
                  <Button
                    type="submit"
                    fullWidth
                    variant="contained"
                    color="primary"
                    className={classes.submit}
                    data-test="transaction-create-submit-request"
                    disabled={!isValid || isSubmitting}
                    onClick={() => setTransactionType("request")}
                  >
                    Request
                  </Button>
                </Grid>
                <Grid item>
                  <Button
                    type="submit"
                    fullWidth
                    variant="contained"
                    color="primary"
                    className={classes.submit}
                    data-test="transaction-create-submit-payment"
                    disabled={!isValid || isSubmitting}
                    onClick={() => setTransactionType("payment")}
                  >
                    Pay
                  </Button>
                </Grid>
              </Grid>
            </Form>
          )}
        </Formik>
      </Container>
    </Paper>
  );
};

export default TransactionCreateStepTwo;



================================================
FILE: cypress-realworld-app/src/components/TransactionDateRangeFilter.tsx
================================================
import React from "react";
import { format as formatDate } from "date-fns";
import { Popover, Chip, useTheme, makeStyles, Drawer, Button } from "@material-ui/core";
import ArrowDropDownIcon from "@material-ui/icons/ArrowDropDown";
import CancelIcon from "@material-ui/icons/Cancel";
import indigo from "@material-ui/core/colors/indigo";
import InfiniteCalendar, { Calendar, withRange } from "react-infinite-calendar";
import useMediaQuery from "@material-ui/core/useMediaQuery";
import "react-infinite-calendar/styles.css";
import { TransactionDateRangePayload } from "../models";
import { hasDateQueryFields } from "../utils/transactionUtils";

const CalendarWithRange = withRange(Calendar);

export type TransactionListDateRangeFilterProps = {
  filterDateRange: Function;
  dateRangeFilters: TransactionDateRangePayload;
  resetDateRange: Function;
};

const useStyles = makeStyles((theme) => ({
  popover: {
    [theme.breakpoints.down("sm")]: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
    },
  },
}));

const TransactionListDateRangeFilter: React.FC<TransactionListDateRangeFilterProps> = ({
  filterDateRange,
  dateRangeFilters,
  resetDateRange,
}) => {
  const classes = useStyles();
  const theme = useTheme();
  const xsBreakpoint = useMediaQuery(theme.breakpoints.only("xs"));
  const queryHasDateFields = dateRangeFilters && hasDateQueryFields(dateRangeFilters);

  const [dateRangeAnchorEl, setDateRangeAnchorEl] = React.useState<HTMLDivElement | null>(null);

  const onCalendarSelect = (e: { eventType: number; start: any; end: any }) => {
    if (e.eventType === 3) {
      filterDateRange({
        dateRangeStart: new Date(e.start.setUTCHours(0, 0, 0, 0)).toISOString(),
        dateRangeEnd: new Date(e.end.setUTCHours(23, 59, 59, 999)).toISOString(),
      });
      setDateRangeAnchorEl(null);
    }
  };

  const handleDateRangeClick = (event: React.MouseEvent<HTMLDivElement>) => {
    setDateRangeAnchorEl(event.currentTarget);
  };

  const handleDateRangeClose = () => {
    setDateRangeAnchorEl(null);
  };

  const dateRangeOpen = Boolean(dateRangeAnchorEl);
  const dateRangeId = dateRangeOpen ? "date-range-popover" : undefined;

  const formatButtonDate = (date: string) => {
    return formatDate(new Date(date), "MMM, d yyyy");
  };

  const dateRangeLabel = (dateRangeFields: TransactionDateRangePayload) => {
    const { dateRangeStart, dateRangeEnd } = dateRangeFields;
    return `${formatButtonDate(dateRangeStart!)} - ${formatButtonDate(dateRangeEnd!)}`;
  };

  return (
    <div>
      {!queryHasDateFields && (
        <Chip
          color="primary"
          variant="outlined"
          onClick={handleDateRangeClick}
          data-test="transaction-list-filter-date-range-button"
          label={"Date: ALL"}
          deleteIcon={<ArrowDropDownIcon />}
          onDelete={handleDateRangeClick}
        />
      )}
      {queryHasDateFields && (
        <Chip
          color="primary"
          variant="outlined"
          onClick={handleDateRangeClick}
          label={`Date: ${dateRangeLabel(dateRangeFilters)}`}
          deleteIcon={<CancelIcon data-test="transaction-list-filter-date-clear-button" />}
          onDelete={() => {
            resetDateRange();
          }}
        />
      )}
      {!xsBreakpoint && (
        <Popover
          id={dateRangeId}
          open={dateRangeOpen}
          anchorEl={dateRangeAnchorEl}
          onClose={handleDateRangeClose}
          anchorOrigin={{
            vertical: "bottom",
            horizontal: "left",
          }}
          transformOrigin={{
            vertical: "top",
            horizontal: "left",
          }}
          className={classes.popover}
        >
          <InfiniteCalendar
            data-test="transaction-list-filter-date-range"
            width={xsBreakpoint ? window.innerWidth : 350}
            height={xsBreakpoint ? window.innerHeight : 300}
            rowHeight={50}
            Component={CalendarWithRange}
            selected={false}
            onSelect={onCalendarSelect}
            locale={{
              headerFormat: "MMM Do",
            }}
            theme={{
              accentColor: indigo["400"],
              headerColor: indigo["500"],
              weekdayColor: indigo["300"],
              selectionColor: indigo["300"],
              floatingNav: {
                background: indigo["400"],
                color: "#FFF",
                chevron: "#FFA726",
              },
            }}
          />
        </Popover>
      )}
      {xsBreakpoint && (
        <Drawer
          id={dateRangeId}
          open={dateRangeOpen}
          ModalProps={{ onClose: handleDateRangeClose }}
          anchor="bottom"
          data-test="date-range-filter-drawer"
        >
          <Button data-test="date-range-filter-drawer-close" onClick={() => handleDateRangeClose()}>
            Close
          </Button>
          <InfiniteCalendar
            data-test="transaction-list-filter-date-range"
            width={window.innerWidth}
            height={window.innerHeight - 185}
            rowHeight={50}
            Component={CalendarWithRange}
            selected={false}
            onSelect={onCalendarSelect}
            locale={{
              headerFormat: "MMM Do",
            }}
            theme={{
              accentColor: indigo["400"],
              headerColor: indigo["500"],
              weekdayColor: indigo["300"],
              selectionColor: indigo["300"],
              floatingNav: {
                background: indigo["400"],
                color: "#FFF",
                chevron: "#FFA726",
              },
            }}
          />
        </Drawer>
      )}
    </div>
  );
};

export default TransactionListDateRangeFilter;



================================================
FILE: cypress-realworld-app/src/components/TransactionDetail.tsx
================================================
import React from "react";
import { Button, Typography, Grid, Avatar, Paper, IconButton } from "@material-ui/core";
import AvatarGroup from "@material-ui/lab/AvatarGroup";
import LikeIcon from "@material-ui/icons/ThumbUpAltOutlined";
import CommentIcon from "@material-ui/icons/CommentRounded";
import { makeStyles } from "@material-ui/core/styles";
import { TransactionResponseItem, TransactionRequestStatus, User } from "../models";
import CommentForm from "./CommentForm";
import {
  isPendingRequestTransaction,
  receiverIsCurrentUser,
  currentUserLikesTransaction,
} from "../utils/transactionUtils";
import CommentsList from "./CommentList";
import TransactionTitle from "./TransactionTitle";
import TransactionAmount from "./TransactionAmount";

const useStyles = makeStyles((theme) => ({
  paper: {
    padding: theme.spacing(2),
    display: "flex",
    overflow: "auto",
    flexDirection: "column",
  },
  paperComments: {
    marginTop: theme.spacing(6),
    padding: theme.spacing(2),
    display: "flex",
    overflow: "auto",
    flexDirection: "column",
  },
  avatar: {
    width: theme.spacing(2),
  },
  headline: {
    marginTop: theme.spacing(4),
  },
  avatarLarge: {
    width: theme.spacing(7),
    height: theme.spacing(7),
  },
  avatarGroup: {
    margin: 10,
  },
  redButton: {
    backgrounColor: "red",
    color: "#ffffff",
    backgroundColor: "red",
    paddingTop: 5,
    paddingBottom: 5,
    paddingRight: 20,
    fontWeight: "bold",
    "&:hover": {
      backgroundColor: "red",
      borderColor: "red",
      boxShadow: "none",
    },
  },
  greenButton: {
    marginRight: theme.spacing(2),
    color: "#ffffff",
    backgroundColor: "#00C853",
    paddingTop: 5,
    paddingBottom: 5,
    paddingRight: 20,
    fontWeight: "bold",
    "&:hover": {
      backgroundColor: "#4CAF50",
      borderColor: "#00C853",
      boxShadow: "none",
    },
  },
}));

type TransactionProps = {
  transaction: TransactionResponseItem;
  transactionLike: Function;
  transactionComment: Function;
  transactionUpdate: Function;
  currentUser: User;
};

const TransactionDetail: React.FC<TransactionProps> = ({
  transaction,
  transactionLike,
  transactionComment,
  transactionUpdate,
  currentUser,
}) => {
  const classes = useStyles();

  return (
    <Paper className={classes.paper}>
      <Typography
        component="h2"
        variant="h6"
        color="primary"
        gutterBottom
        data-test="transaction-detail-header"
      >
        Transaction Detail
      </Typography>
      <Grid
        container
        direction="row"
        justify="space-between"
        alignItems="center"
        data-test={`transaction-item-${transaction.id}`}
      >
        <Grid item className={classes.headline}>
          <AvatarGroup className={classes.avatarGroup} max={2}>
            <Avatar className={classes.avatarLarge} src={transaction.senderAvatar} />
            <Avatar className={classes.avatarLarge} src={transaction.receiverAvatar} />
          </AvatarGroup>
          <Grid container direction="column" justify="flex-start" alignItems="flex-start">
            <Grid item></Grid>
            <Grid item>
              <TransactionTitle transaction={transaction} />
            </Grid>
            <Grid item>
              <Typography variant="body2" color="textSecondary" gutterBottom>
                {transaction.description}
              </Typography>
            </Grid>
          </Grid>
        </Grid>
        <Grid item>
          <TransactionAmount transaction={transaction} />
        </Grid>
      </Grid>
      <Grid container direction="row" justify="flex-start" alignItems="center" spacing={2}>
        <Grid item>
          <Grid container direction="row" justify="flex-start" alignItems="center" spacing={2}>
            <Grid item data-test={`transaction-like-count-${transaction.id}`}>
              {transaction.likes ? transaction.likes.length : 0}{" "}
            </Grid>
            <Grid item>
              <IconButton
                color="primary"
                disabled={currentUserLikesTransaction(currentUser, transaction)}
                onClick={() => transactionLike(transaction.id)}
                data-test={`transaction-like-button-${transaction.id}`}
              >
                <LikeIcon />
              </IconButton>
            </Grid>
            <Grid item>
              {receiverIsCurrentUser(currentUser, transaction) &&
                isPendingRequestTransaction(transaction) && (
                  <Grid item>
                    <Button
                      className={classes.greenButton}
                      variant="contained"
                      size="small"
                      onClick={() =>
                        transactionUpdate({
                          id: transaction.id,
                          requestStatus: TransactionRequestStatus.accepted,
                        })
                      }
                      data-test={`transaction-accept-request-${transaction.id}`}
                    >
                      Accept Request
                    </Button>
                    <Button
                      variant="contained"
                      className={classes.redButton}
                      size="small"
                      onClick={() =>
                        transactionUpdate({
                          id: transaction.id,
                          requestStatus: TransactionRequestStatus.rejected,
                        })
                      }
                      data-test={`transaction-reject-request-${transaction.id}`}
                    >
                      Reject Request
                    </Button>
                  </Grid>
                )}
            </Grid>
          </Grid>
          <Grid item>
            <CommentForm
              transactionId={transaction.id}
              transactionComment={(payload) => transactionComment(payload)}
            />
          </Grid>
        </Grid>
      </Grid>
      {transaction.comments.length > 0 && (
        <Paper className={classes.paperComments}>
          <Typography component="h2" variant="h6" color="primary" gutterBottom>
            <CommentIcon /> Comments
          </Typography>
          <CommentsList comments={transaction.comments} />
        </Paper>
      )}
    </Paper>
  );
};

export default TransactionDetail;



================================================
FILE: cypress-realworld-app/src/components/TransactionInfiniteList.tsx
================================================
import React from "react";
import { get } from "lodash/fp";
import { useTheme, makeStyles } from "@material-ui/core/styles";
import { InfiniteLoader, List, Index } from "react-virtualized";
import "react-virtualized/styles.css"; // only needs to be imported once

import TransactionItem from "./TransactionItem";
import { TransactionResponseItem, TransactionPagination } from "../models";
import { useMediaQuery, Divider } from "@material-ui/core";

export interface TransactionListProps {
  transactions: TransactionResponseItem[];
  loadNextPage: Function;
  pagination: TransactionPagination;
}

const useStyles = makeStyles((theme) => ({
  transactionList: {
    width: "100%",
    minHeight: "80vh",
    display: "flex",
    overflow: "auto",
    flexDirection: "column",
  },
}));

const TransactionInfiniteList: React.FC<TransactionListProps> = ({
  transactions,
  loadNextPage,
  pagination,
}) => {
  const classes = useStyles();
  const theme = useTheme();
  const isXsBreakpoint = useMediaQuery(theme.breakpoints.down("xs"));
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));

  const itemCount = pagination.hasNextPages ? transactions.length + 1 : transactions.length;

  const loadMoreItems = () => {
    return new Promise((resolve) => {
      return resolve(pagination.hasNextPages && loadNextPage(pagination.page + 1));
    });
  };

  const isRowLoaded = (params: Index) =>
    !pagination.hasNextPages || params.index < transactions.length;

  // @ts-ignore
  function rowRenderer({ key, index, style }) {
    const transaction = get(index, transactions);

    if (index < transactions.length) {
      return (
        <div key={key} style={style}>
          <TransactionItem transaction={transaction} />
          <Divider variant={isMobile ? "fullWidth" : "inset"} />
        </div>
      );
    }
  }

  return (
    <InfiniteLoader
      isRowLoaded={isRowLoaded}
      loadMoreRows={loadMoreItems}
      rowCount={itemCount}
      threshold={2}
    >
      {({ onRowsRendered, registerChild }) => (
        <div data-test="transaction-list" className={classes.transactionList}>
          <List
            rowCount={itemCount}
            ref={registerChild}
            onRowsRendered={onRowsRendered}
            height={isXsBreakpoint ? theme.spacing(74) : theme.spacing(88)}
            width={isXsBreakpoint ? theme.spacing(38) : theme.spacing(110)}
            rowHeight={isXsBreakpoint ? theme.spacing(28) : theme.spacing(16)}
            rowRenderer={rowRenderer}
          />
        </div>
      )}
    </InfiniteLoader>
  );
};

export default TransactionInfiniteList;



================================================
FILE: cypress-realworld-app/src/components/TransactionItem.tsx
================================================
import React from "react";
import {
  ListItem,
  Typography,
  Grid,
  Avatar,
  ListItemAvatar,
  Paper,
  Badge,
  withStyles,
  Theme,
  createStyles,
} from "@material-ui/core";
import LikeIcon from "@material-ui/icons/ThumbUpAltOutlined";
import CommentIcon from "@material-ui/icons/CommentRounded";
import { makeStyles } from "@material-ui/core/styles";
import { TransactionResponseItem } from "../models";
import { useHistory } from "react-router";
import TransactionTitle from "./TransactionTitle";
import TransactionAmount from "./TransactionAmount";

const useStyles = makeStyles((theme) => ({
  root: {
    flexGrow: 1,
  },
  paper: {
    padding: theme.spacing(0),
    margin: "auto",
    width: "100%",
  },
  avatar: {
    width: theme.spacing(2),
  },
  socialStats: {
    [theme.breakpoints.down("sm")]: {
      marginTop: theme.spacing(2),
    },
  },
  countIcons: {
    color: theme.palette.grey[400],
  },
  countText: {
    color: theme.palette.grey[400],
    marginTop: 2,
    height: theme.spacing(2),
    width: theme.spacing(2),
  },
}));

type TransactionProps = {
  transaction: TransactionResponseItem;
};

const SmallAvatar = withStyles((theme: Theme) =>
  createStyles({
    root: {
      width: 22,
      height: 22,
      border: `2px solid ${theme.palette.background.paper}`,
    },
  })
)(Avatar);

const TransactionItem: React.FC<TransactionProps> = ({ transaction }) => {
  const classes = useStyles();
  const history = useHistory();

  const showTransactionDetail = (transactionId: string) => {
    history.push(`/transaction/${transactionId}`);
  };

  return (
    <ListItem
      data-test={`transaction-item-${transaction.id}`}
      alignItems="flex-start"
      onClick={() => showTransactionDetail(transaction.id)}
    >
      <Paper className={classes.paper} elevation={0}>
        <Grid container spacing={2}>
          <Grid item>
            <ListItemAvatar>
              <Badge
                overlap="circle"
                anchorOrigin={{
                  vertical: "bottom",
                  horizontal: "right",
                }}
                badgeContent={<SmallAvatar src={transaction.receiverAvatar} />}
              >
                <Avatar src={transaction.senderAvatar} />
              </Badge>
            </ListItemAvatar>
          </Grid>
          <Grid item xs={12} sm container>
            <Grid item xs container direction="column" spacing={2}>
              <Grid item xs>
                <TransactionTitle transaction={transaction} />
                <Typography variant="body2" color="textSecondary" gutterBottom>
                  {transaction.description}
                </Typography>
                <Grid
                  container
                  direction="row"
                  justify="flex-start"
                  alignItems="flex-start"
                  spacing={1}
                  className={classes.socialStats}
                >
                  <Grid item>
                    <LikeIcon className={classes.countIcons} />
                  </Grid>
                  <Grid item>
                    <Typography data-test="transaction-like-count" className={classes.countText}>
                      {transaction.likes.length}
                    </Typography>
                  </Grid>
                  <Grid item>
                    <CommentIcon className={classes.countIcons} />
                  </Grid>
                  <Grid item>
                    <Typography data-test="transaction-comment-count" className={classes.countText}>
                      {transaction.comments.length}
                    </Typography>
                  </Grid>
                </Grid>
              </Grid>
            </Grid>
            <Grid item>
              <TransactionAmount transaction={transaction} />
            </Grid>
          </Grid>
        </Grid>
      </Paper>
    </ListItem>
  );
};

export default TransactionItem;



================================================
FILE: cypress-realworld-app/src/components/TransactionList.tsx
================================================
import React, { ReactNode } from "react";
import Paper from "@material-ui/core/Paper";
import { makeStyles } from "@material-ui/core/styles";
import { Link as RouterLink } from "react-router-dom";
import { Button, ListSubheader, Grid } from "@material-ui/core";
import { isEmpty } from "lodash/fp";

import SkeletonList from "./SkeletonList";
import { TransactionResponseItem, TransactionPagination } from "../models";
import EmptyList from "./EmptyList";
import TransactionInfiniteList from "./TransactionInfiniteList";
import { ReactComponent as TransferMoneyIllustration } from "../svgs/undraw_transfer_money_rywa.svg";

export interface TransactionListProps {
  header: string;
  transactions: TransactionResponseItem[];
  isLoading: Boolean;
  showCreateButton?: Boolean;
  loadNextPage: Function;
  pagination: TransactionPagination;
  filterComponent: ReactNode;
}

const useStyles = makeStyles((theme) => ({
  paper: {
    paddingLeft: theme.spacing(1),
  },
}));

const TransactionList: React.FC<TransactionListProps> = ({
  header,
  transactions,
  isLoading,
  showCreateButton,
  loadNextPage,
  pagination,
  filterComponent,
}) => {
  const classes = useStyles();

  const showEmptyList = !isLoading && transactions?.length === 0;
  const showSkeleton = isLoading && isEmpty(pagination);

  return (
    <Paper className={classes.paper}>
      {filterComponent}
      <ListSubheader component="div">{header}</ListSubheader>
      {showSkeleton && <SkeletonList />}
      {transactions.length > 0 && (
        <TransactionInfiniteList
          transactions={transactions}
          loadNextPage={loadNextPage}
          pagination={pagination}
        />
      )}
      {showEmptyList && (
        <EmptyList entity="Transactions">
          <Grid
            container
            direction="column"
            justify="center"
            alignItems="center"
            style={{ width: "100%" }}
            spacing={2}
          >
            <Grid item>
              <TransferMoneyIllustration style={{ height: 200, width: 300, marginBottom: 30 }} />
            </Grid>
            <Grid item>
              {showCreateButton && (
                <Button
                  data-test="transaction-list-empty-create-transaction-button"
                  variant="contained"
                  color="primary"
                  component={RouterLink}
                  to="/transaction/new"
                >
                  Create A Transaction
                </Button>
              )}
            </Grid>
          </Grid>
        </EmptyList>
      )}
    </Paper>
  );
};

export default TransactionList;



================================================
FILE: cypress-realworld-app/src/components/TransactionListAmountRangeFilter.tsx
================================================
import React from "react";
import {
  makeStyles,
  Grid,
  Popover,
  Typography,
  Slider,
  Chip,
  Button,
  useTheme,
  useMediaQuery,
  Drawer,
} from "@material-ui/core";
import ArrowDropDownIcon from "@material-ui/icons/ArrowDropDown";
import { TransactionAmountRangePayload } from "../models";
import {
  formatAmountRangeValues,
  amountRangeValueText,
  amountRangeValueTextLabel,
  padAmountWithZeros,
  //hasAmountQueryFields
} from "../utils/transactionUtils";
import { first, last } from "lodash/fp";

const useStyles = makeStyles((theme) => ({
  amountRangeRoot: {
    width: 300,
    margin: 30,
  },
  amountRangeTitleRow: {
    width: "100%",
  },
  amountRangeTitle: {
    width: 225,
  },
  amountRangeSlider: {
    width: 200,
  },
}));

export type TransactionListAmountRangeFilterProps = {
  filterAmountRange: Function;
  amountRangeFilters: TransactionAmountRangePayload;
  resetAmountRange: Function;
};

const TransactionListAmountRangeFilter: React.FC<TransactionListAmountRangeFilterProps> = ({
  filterAmountRange,
  amountRangeFilters,
  resetAmountRange,
}) => {
  const classes = useStyles();
  const theme = useTheme();
  const xsBreakpoint = useMediaQuery(theme.breakpoints.only("xs"));

  const initialAmountRange = [0, 100];
  const [amountRangeValue, setAmountRangeValue] = React.useState<number[]>(initialAmountRange);

  const [amountRangeAnchorEl, setAmountRangeAnchorEl] = React.useState<HTMLDivElement | null>(null);

  const handleAmountRangeClick = (event: React.MouseEvent<HTMLDivElement>) => {
    setAmountRangeAnchorEl(event.currentTarget);
  };

  const handleAmountRangeClose = () => {
    setAmountRangeAnchorEl(null);
  };

  const handleAmountRangeChange = (_event: any, amountRange: number | number[]) => {
    filterAmountRange({
      amountMin: padAmountWithZeros(first(amountRange as number[]) as number),
      amountMax: padAmountWithZeros(last(amountRange as number[]) as number),
    });
    setAmountRangeValue(amountRange as number[]);
  };

  const amountRangeOpen = Boolean(amountRangeAnchorEl);
  const amountRangeId = amountRangeOpen ? "amount-range-popover" : undefined;

  const AmountRangeFilter = () => (
    <Grid
      data-test="transaction-list-filter-amount-range"
      container
      direction="column"
      justify="flex-start"
      alignItems="flex-start"
      spacing={1}
      className={classes.amountRangeRoot}
    >
      <Grid item>
        <Grid
          container
          direction="row"
          justify="space-between"
          alignItems="center"
          className={classes.amountRangeTitleRow}
        >
          <Grid item className={classes.amountRangeTitle}>
            <Typography color="textSecondary" data-test="transaction-list-filter-amount-range-text">
              Amount Range: {formatAmountRangeValues(amountRangeValue)}
            </Typography>
          </Grid>
          <Grid item>
            <Button
              data-test="transaction-list-filter-amount-clear-button"
              onClick={() => {
                setAmountRangeValue(initialAmountRange);
                resetAmountRange();
              }}
            >
              Clear
            </Button>
          </Grid>
        </Grid>
      </Grid>
      <Grid item>
        <Slider
          data-test="transaction-list-filter-amount-range-slider"
          className={classes.amountRangeSlider}
          value={amountRangeValue}
          min={0}
          max={100}
          onChange={handleAmountRangeChange}
          valueLabelDisplay="auto"
          aria-labelledby="range-slider"
          getAriaValueText={amountRangeValueText}
          valueLabelFormat={amountRangeValueTextLabel}
        />
      </Grid>
    </Grid>
  );

  return (
    <div>
      <Chip
        color="primary"
        variant="outlined"
        onClick={handleAmountRangeClick}
        data-test="transaction-list-filter-amount-range-button"
        label={`Amount: ${formatAmountRangeValues(amountRangeValue)}`}
        deleteIcon={<ArrowDropDownIcon />}
        onDelete={handleAmountRangeClick}
      />
      {!xsBreakpoint && (
        <Popover
          id={amountRangeId}
          open={amountRangeOpen}
          anchorEl={amountRangeAnchorEl}
          onClose={handleAmountRangeClose}
          anchorOrigin={{
            vertical: "bottom",
            horizontal: "left",
          }}
          transformOrigin={{
            vertical: "top",
            horizontal: "left",
          }}
        >
          <AmountRangeFilter />
        </Popover>
      )}
      {xsBreakpoint && (
        <Drawer
          id={amountRangeId}
          open={amountRangeOpen}
          ModalProps={{ onClose: handleAmountRangeClose }}
          anchor="bottom"
          data-test="amount-range-filter-drawer"
        >
          <Button
            data-test="amount-range-filter-drawer-close"
            onClick={() => handleAmountRangeClose()}
          >
            Close
          </Button>
          <AmountRangeFilter />
        </Drawer>
      )}
    </div>
  );
};

export default TransactionListAmountRangeFilter;



================================================
FILE: cypress-realworld-app/src/components/TransactionListFilters.tsx
================================================
import React from "react";
import { makeStyles, Paper, Grid } from "@material-ui/core";
import { TransactionDateRangePayload, TransactionAmountRangePayload } from "../models";
import TransactionListDateRangeFilter from "./TransactionDateRangeFilter";
import TransactionListAmountRangeFilter from "./TransactionListAmountRangeFilter";
import { debounce } from "lodash/fp";

const useStyles = makeStyles((theme) => ({
  paper: {
    padding: theme.spacing(2),
    display: "flex",
    overflow: "auto",
    flexDirection: "column",
  },
}));

export type TransactionListFiltersProps = {
  sendFilterEvent: Function;
  dateRangeFilters: TransactionDateRangePayload;
  amountRangeFilters: TransactionAmountRangePayload;
};

const TransactionListFilters: React.FC<TransactionListFiltersProps> = ({
  sendFilterEvent,
  dateRangeFilters,
  amountRangeFilters,
}) => {
  const classes = useStyles();

  const filterDateRange = (payload: TransactionDateRangePayload) =>
    sendFilterEvent("DATE_FILTER", payload);
  const resetDateRange = () => sendFilterEvent("DATE_RESET");

  const filterAmountRange = debounce(200, (payload: TransactionAmountRangePayload) =>
    sendFilterEvent("AMOUNT_FILTER", payload)
  );
  const resetAmountRange = () => sendFilterEvent("AMOUNT_RESET");

  return (
    <Paper className={classes.paper} elevation={0}>
      <Grid container direction="row" justify="flex-start" alignItems="flex-start" spacing={1}>
        <Grid item>
          <TransactionListDateRangeFilter
            filterDateRange={filterDateRange}
            dateRangeFilters={dateRangeFilters}
            resetDateRange={resetDateRange}
          />
        </Grid>
        <Grid item>
          <TransactionListAmountRangeFilter
            filterAmountRange={filterAmountRange}
            amountRangeFilters={amountRangeFilters}
            resetAmountRange={resetAmountRange}
          />
        </Grid>
      </Grid>
    </Paper>
  );
};

export default TransactionListFilters;



================================================
FILE: cypress-realworld-app/src/components/TransactionNavTabs.tsx
================================================
import React from "react";
import Tabs from "@material-ui/core/Tabs";
import Tab from "@material-ui/core/Tab";
import { Link, useRouteMatch } from "react-router-dom";

export default function TransactionNavTabs() {
  const match = useRouteMatch();

  // Route Lookup for tabs
  const navUrls: any = {
    "/": 0,
    "/public": 0,
    "/contacts": 1,
    "/personal": 2,
  };

  // Set selected tab based on url
  const [value, setValue] = React.useState(navUrls[match.url]);

  const handleChange = (event: React.ChangeEvent<{}>, newValue: number) => {
    setValue(newValue);
  };

  return (
    <Tabs
      value={value}
      onChange={handleChange}
      indicatorColor="secondary"
      centered
      data-test="nav-transaction-tabs"
    >
      <Tab label="Everyone" component={Link} to="/" data-test="nav-public-tab" />
      <Tab label="Friends" component={Link} to="/contacts" data-test="nav-contacts-tab" />
      <Tab label="Mine" component={Link} to="/personal" data-test="nav-personal-tab" />
    </Tabs>
  );
}



================================================
FILE: cypress-realworld-app/src/components/TransactionPersonalList.tsx
================================================
import React, { useEffect, ReactNode } from "react";
import { useMachine } from "@xstate/react";
import {
  TransactionPagination,
  TransactionResponseItem,
  TransactionDateRangePayload,
  TransactionAmountRangePayload,
} from "../models";
import TransactionList from "./TransactionList";
import { personalTransactionsMachine } from "../machines/personalTransactionsMachine";

export interface TransactionPersonalListProps {
  filterComponent: ReactNode;
  dateRangeFilters: TransactionDateRangePayload;
  amountRangeFilters: TransactionAmountRangePayload;
}

const TransactionPersonalList: React.FC<TransactionPersonalListProps> = ({
  filterComponent,
  dateRangeFilters,
  amountRangeFilters,
}) => {
  const [current, send, personalTransactionService] = useMachine(personalTransactionsMachine);
  const { pageData, results } = current.context;

  // @ts-ignore
  if (window.Cypress) {
    // @ts-ignore
    window.personalTransactionService = personalTransactionService;
  }

  useEffect(() => {
    send("FETCH", { ...dateRangeFilters, ...amountRangeFilters });
  }, [send, dateRangeFilters, amountRangeFilters]);

  const loadNextPage = (page: number) =>
    send("FETCH", { page, ...dateRangeFilters, ...amountRangeFilters });

  return (
    <>
      <TransactionList
        filterComponent={filterComponent}
        header="Personal"
        transactions={results as TransactionResponseItem[]}
        isLoading={current.matches("loading")}
        loadNextPage={loadNextPage}
        pagination={pageData as TransactionPagination}
        showCreateButton={true}
      />
    </>
  );
};

export default TransactionPersonalList;



================================================
FILE: cypress-realworld-app/src/components/TransactionPublicList.tsx
================================================
import React, { useEffect, ReactNode } from "react";
import { useMachine } from "@xstate/react";
import {
  TransactionPagination,
  TransactionResponseItem,
  TransactionDateRangePayload,
  TransactionAmountRangePayload,
} from "../models";
import TransactionList from "./TransactionList";
import { publicTransactionsMachine } from "../machines/publicTransactionsMachine";

export interface TransactionPublicListProps {
  filterComponent: ReactNode;
  dateRangeFilters: TransactionDateRangePayload;
  amountRangeFilters: TransactionAmountRangePayload;
}

const TransactionPublicList: React.FC<TransactionPublicListProps> = ({
  filterComponent,
  dateRangeFilters,
  amountRangeFilters,
}) => {
  const [current, send, publicTransactionService] = useMachine(publicTransactionsMachine);
  const { pageData, results } = current.context;

  // @ts-ignore
  if (window.Cypress) {
    // @ts-ignore
    window.publicTransactionService = publicTransactionService;
  }

  useEffect(() => {
    send("FETCH", { ...dateRangeFilters, ...amountRangeFilters });
  }, [send, dateRangeFilters, amountRangeFilters]);

  const loadNextPage = (page: number) =>
    send("FETCH", { page, ...dateRangeFilters, ...amountRangeFilters });

  return (
    <>
      <TransactionList
        filterComponent={filterComponent}
        header="Public"
        transactions={results as TransactionResponseItem[]}
        isLoading={current.matches("loading")}
        loadNextPage={loadNextPage}
        pagination={pageData as TransactionPagination}
        showCreateButton
      />
    </>
  );
};

export default TransactionPublicList;



================================================
FILE: cypress-realworld-app/src/components/TransactionTitle.tsx
================================================
import React from "react";
import { Typography } from "@material-ui/core";
import { makeStyles } from "@material-ui/core/styles";
import { TransactionResponseItem } from "../models";
import { isRequestTransaction, isAcceptedRequestTransaction } from "../utils/transactionUtils";

const useStyles = makeStyles((theme) => ({
  title: {
    fontSize: 18,
    [theme.breakpoints.down("sm")]: {
      fontSize: theme.typography.fontSize,
    },
  },
  titleAction: {
    fontSize: 18,
    [theme.breakpoints.down("sm")]: {
      fontSize: theme.typography.fontSize,
    },
  },
  titleName: {
    fontSize: 18,
    [theme.breakpoints.down("sm")]: {
      fontSize: theme.typography.fontSize,
    },
    color: "#1A202C",
  },
}));

const TransactionTitle: React.FC<{
  transaction: TransactionResponseItem;
}> = ({ transaction }) => {
  const classes = useStyles();

  return (
    <Typography color="textSecondary" className={classes.title} gutterBottom>
      <Typography
        data-test={`transaction-sender-${transaction.id}`}
        className={classes.titleName}
        display="inline"
        component="span"
      >
        {transaction.senderName}
      </Typography>
      <Typography
        data-test={`transaction-action-${transaction.id}`}
        display="inline"
        className={classes.titleAction}
        component="span"
      >
        {isRequestTransaction(transaction)
          ? isAcceptedRequestTransaction(transaction)
            ? " charged "
            : " requested "
          : " paid "}
      </Typography>
      <Typography
        data-test={`transaction-receiver-${transaction.id}`}
        className={classes.titleName}
        display="inline"
        component="span"
      >
        {transaction.receiverName}
      </Typography>
    </Typography>
  );
};

export default TransactionTitle;



================================================
FILE: cypress-realworld-app/src/components/UserListItem.tsx
================================================
import React from "react";

import ListItem from "@material-ui/core/ListItem";
import { User } from "../models";
import { ListItemText, ListItemAvatar, Avatar, Grid } from "@material-ui/core";

export interface UserListItemProps {
  user: User;
  setReceiver: Function;
  index: Number;
}

const UserListItem: React.FC<UserListItemProps> = ({ user, setReceiver, index }) => {
  return (
    <ListItem data-test={`user-list-item-${user.id}`} onClick={() => setReceiver(user)}>
      <ListItemAvatar>
        <Avatar src={user.avatar} />
      </ListItemAvatar>
      <ListItemText
        primary={`${user.firstName} ${user.lastName}`}
        secondary={
          <span>
            <Grid
              component={"span"}
              container
              direction="row"
              justify="flex-start"
              alignItems="flex-start"
              spacing={1}
            >
              <Grid item component={"span"}>
                <b>U: </b>
                {user.username}
              </Grid>
              <Grid item component={"span"}>
                &bull;
              </Grid>
              <Grid item component={"span"}>
                <b>E: </b>
                {user.email}
              </Grid>
              <Grid item component={"span"}>
                &bull;
              </Grid>
              <Grid item component={"span"}>
                <b>P: </b>
                {user.phoneNumber}
              </Grid>
            </Grid>
          </span>
        }
      />
    </ListItem>
  );
};

export default UserListItem;



================================================
FILE: cypress-realworld-app/src/components/UserListSearchForm.tsx
================================================
import React, { useRef } from "react";
import TextField from "@material-ui/core/TextField";
import { makeStyles } from "@material-ui/core/styles";

const useStyles = makeStyles((theme) => ({
  paper: {
    marginTop: theme.spacing(8),
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  form: {
    width: "100%", // Fix IE 11 issue.
    marginTop: theme.spacing(1),
  },
}));

export interface UserListSearchFormProps {
  userListSearch: Function;
}

const UserListSearchForm: React.FC<UserListSearchFormProps> = ({ userListSearch }) => {
  const classes = useStyles();
  const inputEl = useRef<HTMLInputElement>(null);

  return (
    <div>
      <form className={classes.form}>
        <TextField
          variant="outlined"
          margin="dense"
          fullWidth
          name="q"
          type="text"
          placeholder="Search..."
          id="user-list-search-input"
          inputRef={inputEl}
          inputProps={{ "data-test": "user-list-search-input" }}
          onFocus={() => {
            if (null !== inputEl.current) {
              inputEl.current.value = "";
              inputEl.current.focus();
            }
          }}
          onChange={({ target: { value: q } }) => {
            userListSearch({ q });
          }}
        />
      </form>
    </div>
  );
};

export default UserListSearchForm;



================================================
FILE: cypress-realworld-app/src/components/UserSettingsForm.tsx
================================================
import React from "react";
import TextField from "@material-ui/core/TextField";
import { makeStyles } from "@material-ui/core/styles";
import { Formik, Form, Field, FieldProps } from "formik";
import { string, object, mixed } from "yup";
import { Button, Grid } from "@material-ui/core";
import { User, DefaultPrivacyLevel, UserSettingsPayload } from "../models";

const phoneRegExp = /^((\\+[1-9]{1,4}[ \\-]*)|(\\([0-9]{2,3}\\)[ \\-]*)|([0-9]{2,4})[ \\-]*)*?[0-9]{3,4}?[ \\-]*[0-9]{3,4}?$/;

const DefaultPrivacyLevelValues = Object.values(DefaultPrivacyLevel);

const validationSchema = object({
  firstName: string().required("Enter a first name"),
  lastName: string().required("Enter a last name"),
  email: string().email("Must contain a valid email address").required("Enter an email address"),
  phoneNumber: string()
    .matches(phoneRegExp, "Phone number is not valid")
    .required("Enter a phone number"),
  defaultPrivacyLevel: mixed<DefaultPrivacyLevel>().oneOf(DefaultPrivacyLevelValues),
});

const useStyles = makeStyles((theme) => ({
  paper: {
    marginTop: theme.spacing(8),
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  form: {
    width: "100%", // Fix IE 11 issue.
    marginTop: theme.spacing(1),
  },
  submit: {
    margin: theme.spacing(3, 0, 2),
  },
}));

export interface UserSettingsProps {
  userProfile: User;
  updateUser: Function;
}

const UserSettingsForm: React.FC<UserSettingsProps> = ({ userProfile, updateUser }) => {
  const classes = useStyles();
  const initialValues: UserSettingsPayload = {
    firstName: userProfile.firstName,
    lastName: userProfile.lastName,
    email: userProfile.email,
    phoneNumber: userProfile.phoneNumber,
    defaultPrivacyLevel: userProfile.defaultPrivacyLevel,
  };

  return (
    <Formik
      initialValues={initialValues}
      validationSchema={validationSchema}
      onSubmit={(values, { setSubmitting }) => {
        setSubmitting(true);
        updateUser({ id: userProfile.id, ...values });
        setSubmitting(false);
      }}
    >
      {({ isValid, isSubmitting }) => (
        <Form className={classes.form} data-test="user-settings-form">
          <Field name="firstName">
            {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
              <TextField
                variant="outlined"
                margin="dense"
                fullWidth
                required
                id={"user-settings-firstName-input"}
                type="text"
                placeholder="First Name"
                inputProps={{ "data-test": "user-settings-firstName-input" }}
                error={(touched || value !== initialValue) && Boolean(error)}
                helperText={touched || value !== initialValue ? error : ""}
                {...field}
              />
            )}
          </Field>
          <Field name="lastName">
            {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
              <TextField
                variant="outlined"
                margin="dense"
                fullWidth
                required
                id={"user-settings-lastName-input"}
                type="text"
                placeholder="Last Name"
                inputProps={{ "data-test": "user-settings-lastName-input" }}
                error={(touched || value !== initialValue) && Boolean(error)}
                helperText={touched || value !== initialValue ? error : ""}
                {...field}
              />
            )}
          </Field>
          <Field name="email">
            {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
              <TextField
                variant="outlined"
                margin="dense"
                fullWidth
                required
                id={"user-settings-email-input"}
                type="text"
                placeholder="Email"
                inputProps={{ "data-test": "user-settings-email-input" }}
                error={(touched || value !== initialValue) && Boolean(error)}
                helperText={touched || value !== initialValue ? error : ""}
                {...field}
              />
            )}
          </Field>
          <Field name="phoneNumber">
            {({ field, meta: { error, value, initialValue, touched } }: FieldProps) => (
              <TextField
                variant="outlined"
                margin="dense"
                fullWidth
                required
                id={"user-settings-phoneNumber-input"}
                type="text"
                placeholder="Phone Number"
                inputProps={{ "data-test": "user-settings-phoneNumber-input" }}
                error={(touched || value !== initialValue) && Boolean(error)}
                helperText={touched || value !== initialValue ? error : ""}
                {...field}
              />
            )}
          </Field>
          <Grid container spacing={2} direction="row" justify="flex-start" alignItems="flex-start">
            <Grid item>
              <Button
                type="submit"
                fullWidth
                variant="contained"
                color="primary"
                className={classes.submit}
                data-test="user-settings-submit"
                disabled={!isValid || isSubmitting}
              >
                Save
              </Button>
            </Grid>
          </Grid>
        </Form>
      )}
    </Formik>
  );
};

export default UserSettingsForm;



================================================
FILE: cypress-realworld-app/src/components/UsersList.tsx
================================================
import React from "react";

import UserListItem from "./UserListItem";
import List from "@material-ui/core/List";
import { User } from "../models";

export interface UsersListProps {
  users: User[];
  setReceiver: Function;
}

const UsersList: React.FC<UsersListProps> = ({ users, setReceiver }) => {
  return (
    <List data-test="users-list">
      {users &&
        users.map((user: User, index: number) => (
          <UserListItem key={user.id} user={user} setReceiver={setReceiver} index={index} />
        ))}
    </List>
  );
};

export default UsersList;



================================================
FILE: cypress-realworld-app/src/containers/App.tsx
================================================
import React from "react";
import { Switch, Route, Redirect } from "react-router-dom";
import { useService, useMachine } from "@xstate/react";
import { makeStyles } from "@material-ui/core/styles";
import { CssBaseline } from "@material-ui/core";

import { snackbarMachine } from "../machines/snackbarMachine";
import { notificationsMachine } from "../machines/notificationsMachine";
import { authService } from "../machines/authMachine";
import AlertBar from "../components/AlertBar";
import SignInForm from "../components/SignInForm";
import SignUpForm from "../components/SignUpForm";
import { bankAccountsMachine } from "../machines/bankAccountsMachine";
import PrivateRoutesContainer from "./PrivateRoutesContainer";

// @ts-ignore
if (window.Cypress) {
  // Expose authService on window for Cypress
  // @ts-ignore
  window.authService = authService;
}

const useStyles = makeStyles((theme) => ({
  root: {
    display: "flex",
  },
}));

const App: React.FC = () => {
  const classes = useStyles();
  const [authState] = useService(authService);
  const [, , notificationsService] = useMachine(notificationsMachine);

  const [, , snackbarService] = useMachine(snackbarMachine);

  const [, , bankAccountsService] = useMachine(bankAccountsMachine);

  const isLoggedIn =
    authState.matches("authorized") ||
    authState.matches("refreshing") ||
    authState.matches("updating");

  return (
    <div className={classes.root}>
      <CssBaseline />

      {isLoggedIn && (
        <PrivateRoutesContainer
          isLoggedIn={isLoggedIn}
          notificationsService={notificationsService}
          authService={authService}
          snackbarService={snackbarService}
          bankAccountsService={bankAccountsService}
        />
      )}
      {authState.matches("unauthorized") && (
        <Switch>
          <Route exact path="/signup">
            <SignUpForm authService={authService} />
          </Route>
          <Route exact path="/signin">
            <SignInForm authService={authService} />
          </Route>
          <Route path="/*">
            <Redirect
              to={{
                pathname: "/signin",
              }}
            />
          </Route>
        </Switch>
      )}
      <AlertBar snackbarService={snackbarService} />
    </div>
  );
};

export default App;



================================================
FILE: cypress-realworld-app/src/containers/BankAccountsContainer.tsx
================================================
import React, { useEffect } from "react";
import { useService } from "@xstate/react";
import { Link as RouterLink, useRouteMatch } from "react-router-dom";
import Typography from "@material-ui/core/Typography";
import Paper from "@material-ui/core/Paper";
import { makeStyles } from "@material-ui/core/styles";
import BankAccountList from "../components/BankAccountList";
import { Grid, Button } from "@material-ui/core";
import BankAccountForm from "../components/BankAccountForm";
import { Interpreter } from "xstate";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";
import { DataContext, DataEvents } from "../machines/dataMachine";

export interface Props {
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
  bankAccountsService: Interpreter<DataContext, any, DataEvents, any>;
}

const useStyles = makeStyles((theme) => ({
  paper: {
    padding: theme.spacing(2),
    display: "flex",
    overflow: "auto",
    flexDirection: "column",
  },
}));

const BankAccountsContainer: React.FC<Props> = ({ authService, bankAccountsService }) => {
  const match = useRouteMatch();
  const classes = useStyles();
  const [authState] = useService(authService);
  const [bankAccountsState, sendBankAccounts] = useService(bankAccountsService);

  const currentUser = authState?.context.user;

  const createBankAccount = (payload: any) => {
    sendBankAccounts("CREATE", payload);
  };

  const deleteBankAccount = (payload: any) => {
    sendBankAccounts("DELETE", payload);
  };

  useEffect(() => {
    sendBankAccounts("FETCH");
  }, [sendBankAccounts]);

  if (match.url === "/bankaccounts/new" && currentUser?.id) {
    return (
      <Paper className={classes.paper}>
        <Typography component="h2" variant="h6" color="primary" gutterBottom>
          Create Bank Account
        </Typography>
        <BankAccountForm userId={currentUser?.id} createBankAccount={createBankAccount} />
      </Paper>
    );
  }

  return (
    <Paper className={classes.paper}>
      <Grid container direction="row" justify="space-between" alignItems="center">
        <Grid item>
          <Typography component="h2" variant="h6" color="primary" gutterBottom>
            Bank Accounts
          </Typography>
        </Grid>
        <Grid item>
          <Button
            variant="contained"
            color="primary"
            size="large"
            component={RouterLink}
            to="/bankaccounts/new"
            data-test="bankaccount-new"
          >
            Create
          </Button>
        </Grid>
      </Grid>
      <BankAccountList
        bankAccounts={bankAccountsState?.context.results!}
        deleteBankAccount={deleteBankAccount}
      />
    </Paper>
  );
};
export default BankAccountsContainer;



================================================
FILE: cypress-realworld-app/src/containers/NotificationsContainer.tsx
================================================
import React, { useEffect } from "react";
import { Interpreter } from "xstate";
import { useService } from "@xstate/react";
import { makeStyles, Paper, Typography } from "@material-ui/core";
import { NotificationUpdatePayload } from "../models";
import NotificationList from "../components/NotificationList";
import { DataContext, DataSchema, DataEvents } from "../machines/dataMachine";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";

const useStyles = makeStyles((theme) => ({
  paper: {
    minHeight: "90vh",
    padding: theme.spacing(2),
    display: "flex",
    overflow: "auto",
    flexDirection: "column",
  },
}));

export interface Props {
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
  notificationsService: Interpreter<DataContext, DataSchema, DataEvents, any>;
}

const NotificationsContainer: React.FC<Props> = ({ authService, notificationsService }) => {
  const classes = useStyles();
  const [authState] = useService(authService);
  const [notificationsState, sendNotifications] = useService(notificationsService);

  useEffect(() => {
    sendNotifications({ type: "FETCH" });
  }, [authState, sendNotifications]);

  const updateNotification = (payload: NotificationUpdatePayload) =>
    sendNotifications("UPDATE", payload);

  return (
    <Paper className={classes.paper}>
      <Typography component="h2" variant="h6" color="primary" gutterBottom>
        Notifications
      </Typography>
      <NotificationList
        notifications={notificationsState?.context?.results!}
        updateNotification={updateNotification}
      />
    </Paper>
  );
};

export default NotificationsContainer;



================================================
FILE: cypress-realworld-app/src/containers/PrivateRoutesContainer.tsx
================================================
import React, { useEffect } from "react";
import { Switch } from "react-router";
import { Interpreter } from "xstate";
import MainLayout from "../components/MainLayout";
import PrivateRoute from "../components/PrivateRoute";
import TransactionsContainer from "./TransactionsContainer";
import UserSettingsContainer from "./UserSettingsContainer";
import NotificationsContainer from "./NotificationsContainer";
import BankAccountsContainer from "./BankAccountsContainer";
import TransactionCreateContainer from "./TransactionCreateContainer";
import TransactionDetailContainer from "./TransactionDetailContainer";
import { DataContext, DataSchema, DataEvents } from "../machines/dataMachine";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";
import { SnackbarContext, SnackbarSchema, SnackbarEvents } from "../machines/snackbarMachine";
import { useService } from "@xstate/react";
import UserOnboardingContainer from "./UserOnboardingContainer";

export interface Props {
  isLoggedIn: boolean;
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
  notificationsService: Interpreter<DataContext, DataSchema, DataEvents, any>;
  snackbarService: Interpreter<SnackbarContext, SnackbarSchema, SnackbarEvents, any>;
  bankAccountsService: Interpreter<DataContext, any, DataEvents, any>;
}

const PrivateRoutesContainer: React.FC<Props> = ({
  isLoggedIn,
  authService,
  notificationsService,
  snackbarService,
  bankAccountsService,
}) => {
  const [, sendNotifications] = useService(notificationsService);

  useEffect(() => {
    sendNotifications({ type: "FETCH" });
  }, [sendNotifications]);

  return (
    <MainLayout notificationsService={notificationsService} authService={authService}>
      <UserOnboardingContainer
        authService={authService}
        bankAccountsService={bankAccountsService}
      />
      <Switch>
        <PrivateRoute isLoggedIn={isLoggedIn} exact path={"/(public|contacts|personal)?"}>
          <TransactionsContainer />
        </PrivateRoute>
        <PrivateRoute isLoggedIn={isLoggedIn} exact path="/user/settings">
          <UserSettingsContainer authService={authService} />
        </PrivateRoute>
        <PrivateRoute isLoggedIn={isLoggedIn} exact path="/notifications">
          <NotificationsContainer
            authService={authService}
            notificationsService={notificationsService}
          />
        </PrivateRoute>
        <PrivateRoute isLoggedIn={isLoggedIn} path="/bankaccounts*">
          <BankAccountsContainer
            authService={authService}
            bankAccountsService={bankAccountsService}
          />
        </PrivateRoute>
        <PrivateRoute isLoggedIn={isLoggedIn} exact path="/transaction/new">
          <TransactionCreateContainer authService={authService} snackbarService={snackbarService} />
        </PrivateRoute>
        <PrivateRoute isLoggedIn={isLoggedIn} exact path="/transaction/:transactionId">
          <TransactionDetailContainer authService={authService} />
        </PrivateRoute>
      </Switch>
    </MainLayout>
  );
};

export default PrivateRoutesContainer;



================================================
FILE: cypress-realworld-app/src/containers/TransactionCreateContainer.tsx
================================================
import React, { useEffect } from "react";
import { useMachine, useService } from "@xstate/react";
import { User, TransactionPayload } from "../models";
import TransactionCreateStepOne from "../components/TransactionCreateStepOne";
import TransactionCreateStepTwo from "../components/TransactionCreateStepTwo";
import TransactionCreateStepThree from "../components/TransactionCreateStepThree";
import { createTransactionMachine } from "../machines/createTransactionMachine";
import { usersMachine } from "../machines/usersMachine";
import { debounce } from "lodash/fp";
import { Interpreter } from "xstate";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";
import { SnackbarSchema, SnackbarContext, SnackbarEvents } from "../machines/snackbarMachine";
import { Stepper, Step, StepLabel } from "@material-ui/core";

export interface Props {
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
  snackbarService: Interpreter<SnackbarContext, SnackbarSchema, SnackbarEvents, any>;
}

const TransactionCreateContainer: React.FC<Props> = ({ authService, snackbarService }) => {
  const [authState] = useService(authService);
  const [, sendSnackbar] = useService(snackbarService);

  const [createTransactionState, sendCreateTransaction, createTransactionService] = useMachine(
    createTransactionMachine
  );

  // Expose createTransactionService on window for Cypress
  // @ts-ignore
  window.createTransactionService = createTransactionService;

  const [usersState, sendUsers] = useMachine(usersMachine);

  useEffect(() => {
    sendUsers({ type: "FETCH" });
  }, [sendUsers]);

  const sender = authState?.context?.user;
  const setReceiver = (receiver: User) => {
    sendCreateTransaction("SET_USERS", { sender, receiver });
  };
  const createTransaction = (payload: TransactionPayload) => {
    sendCreateTransaction("CREATE", payload);
  };
  const userListSearch = debounce(200, (payload: any) => sendUsers("FETCH", payload));

  const showSnackbar = (payload: SnackbarContext) => sendSnackbar("SHOW", payload);

  let activeStep;
  if (createTransactionState.matches("stepTwo")) {
    activeStep = 1;
  } else if (createTransactionState.matches("stepThree")) {
    activeStep = 3;
  } else {
    activeStep = 0;
  }

  return (
    <>
      <Stepper activeStep={activeStep}>
        <Step key={"stepOne"}>
          <StepLabel>Select Contact</StepLabel>
        </Step>
        <Step key={"stepTwo"}>
          <StepLabel>Payment</StepLabel>
        </Step>
        <Step key={"stepThree"}>
          <StepLabel>Complete</StepLabel>
        </Step>
      </Stepper>
      {createTransactionState.matches("stepOne") && (
        <TransactionCreateStepOne
          setReceiver={setReceiver}
          users={usersState.context.results!}
          userListSearch={userListSearch}
        />
      )}
      {sender && createTransactionState.matches("stepTwo") && (
        <TransactionCreateStepTwo
          receiver={createTransactionState.context.receiver}
          sender={sender}
          createTransaction={createTransaction}
          showSnackbar={showSnackbar}
        />
      )}
      {createTransactionState.matches("stepThree") && (
        <TransactionCreateStepThree createTransactionService={createTransactionService} />
      )}
    </>
  );
};

export default TransactionCreateContainer;



================================================
FILE: cypress-realworld-app/src/containers/TransactionDetailContainer.tsx
================================================
import React, { useEffect } from "react";
import { useMachine, useService } from "@xstate/react";
import { useParams } from "react-router-dom";
import TransactionDetail from "../components/TransactionDetail";
import { Transaction } from "../models";
import { transactionDetailMachine } from "../machines/transactionDetailMachine";
import { first } from "lodash/fp";
import { Interpreter } from "xstate";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";

export interface Props {
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
}
interface Params {
  transactionId: string;
}

const TransactionDetailsContainer: React.FC<Props> = ({ authService }) => {
  const { transactionId }: Params = useParams();
  const [authState] = useService(authService);
  const [transactionDetailState, sendTransactionDetail] = useMachine(transactionDetailMachine);
  useEffect(() => {
    sendTransactionDetail("FETCH", { transactionId });
  }, [sendTransactionDetail, transactionId]);

  const transactionLike = (transactionId: Transaction["id"]) =>
    sendTransactionDetail("CREATE", { entity: "LIKE", transactionId });

  const transactionComment = (payload: any) =>
    sendTransactionDetail("CREATE", { entity: "COMMENT", ...payload });

  const transactionUpdate = (payload: any) => sendTransactionDetail("UPDATE", payload);

  const transaction = first(transactionDetailState.context?.results);
  const currentUser = authState?.context?.user;

  return (
    <>
      {transactionDetailState.matches("idle") && (
        <div>
          Loading...
          <br />
        </div>
      )}
      {currentUser && transactionDetailState.matches("success") && (
        <TransactionDetail
          transaction={transaction}
          transactionLike={transactionLike}
          transactionComment={transactionComment}
          transactionUpdate={transactionUpdate}
          currentUser={currentUser}
        />
      )}
    </>
  );
};

export default TransactionDetailsContainer;



================================================
FILE: cypress-realworld-app/src/containers/TransactionsContainer.tsx
================================================
import React from "react";
import { useMachine } from "@xstate/react";
import { Switch, Route } from "react-router";
import { TransactionDateRangePayload, TransactionAmountRangePayload } from "../models";
import TransactionListFilters from "../components/TransactionListFilters";
import TransactionContactsList from "../components/TransactionContactsList";
import { transactionFiltersMachine } from "../machines/transactionFiltersMachine";
import { getDateQueryFields, getAmountQueryFields } from "../utils/transactionUtils";
import TransactionPersonalList from "../components/TransactionPersonalList";
import TransactionPublicList from "../components/TransactionPublicList";

const TransactionsContainer: React.FC = () => {
  const [currentFilters, sendFilterEvent] = useMachine(transactionFiltersMachine);

  const hasDateRangeFilter = currentFilters.matches({ dateRange: "filter" });
  const hasAmountRangeFilter = currentFilters.matches({
    amountRange: "filter",
  });

  const dateRangeFilters = hasDateRangeFilter && getDateQueryFields(currentFilters.context);
  const amountRangeFilters = hasAmountRangeFilter && getAmountQueryFields(currentFilters.context);

  const Filters = (
    <TransactionListFilters
      dateRangeFilters={dateRangeFilters as TransactionDateRangePayload}
      amountRangeFilters={amountRangeFilters as TransactionAmountRangePayload}
      sendFilterEvent={sendFilterEvent}
    />
  );

  return (
    <Switch>
      <Route exact path="/contacts">
        <TransactionContactsList
          filterComponent={Filters}
          dateRangeFilters={dateRangeFilters as TransactionDateRangePayload}
          amountRangeFilters={amountRangeFilters as TransactionAmountRangePayload}
        />
      </Route>
      <Route exact path="/personal">
        <TransactionPersonalList
          filterComponent={Filters}
          dateRangeFilters={dateRangeFilters as TransactionDateRangePayload}
          amountRangeFilters={amountRangeFilters as TransactionAmountRangePayload}
        />
      </Route>
      <Route exact path="/(public)?">
        <TransactionPublicList
          filterComponent={Filters}
          dateRangeFilters={dateRangeFilters as TransactionDateRangePayload}
          amountRangeFilters={amountRangeFilters as TransactionAmountRangePayload}
        />
      </Route>
    </Switch>
  );
};

export default TransactionsContainer;



================================================
FILE: cypress-realworld-app/src/containers/UserOnboardingContainer.tsx
================================================
import React, { useEffect } from "react";
import Button from "@material-ui/core/Button";
import Dialog from "@material-ui/core/Dialog";
import DialogActions from "@material-ui/core/DialogActions";
import DialogContent from "@material-ui/core/DialogContent";
import DialogContentText from "@material-ui/core/DialogContentText";
import DialogTitle from "@material-ui/core/DialogTitle";
import { Box, useTheme, useMediaQuery, Grid } from "@material-ui/core";
import { Interpreter } from "xstate";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";
import { useService, useMachine } from "@xstate/react";
import { userOnboardingMachine } from "../machines/userOnboardingMachine";
import { isEmpty } from "lodash/fp";
import BankAccountForm from "../components/BankAccountForm";
import { DataContext, DataEvents } from "../machines/dataMachine";
import { ReactComponent as NavigatorIllustration } from "../svgs/undraw_navigator_a479.svg";
import { ReactComponent as PersonalFinance } from "../svgs/undraw_personal_finance_tqcd.svg";

export interface Props {
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
  bankAccountsService: Interpreter<DataContext, any, DataEvents, any>;
}

const UserOnboardingContainer: React.FC<Props> = ({ authService, bankAccountsService }) => {
  const theme = useTheme();
  const fullScreen = useMediaQuery(theme.breakpoints.down("sm"));
  const [bankAccountsState, sendBankAccounts] = useService(bankAccountsService);
  const [authState, sendAuth] = useService(authService);
  const [userOnboardingState, sendUserOnboarding] = useMachine(userOnboardingMachine);

  const currentUser = authState?.context?.user;

  useEffect(() => {
    sendBankAccounts("FETCH");
  }, [sendBankAccounts]);

  const noBankAccounts =
    bankAccountsState?.matches("success.withoutData") &&
    isEmpty(bankAccountsState?.context?.results);

  const dialogIsOpen =
    (userOnboardingState.matches("stepTwo") && !noBankAccounts) ||
    (userOnboardingState.matches("stepThree") && !noBankAccounts) ||
    (!userOnboardingState.matches("done") && noBankAccounts) ||
    false;

  const nextStep = () => sendUserOnboarding("NEXT");

  const createBankAccountWithNextStep = (payload: any) => {
    sendBankAccounts("CREATE", payload);
    nextStep();
  };

  return (
    <Dialog data-test="user-onboarding-dialog" fullScreen={fullScreen} open={dialogIsOpen}>
      <DialogTitle data-test="user-onboarding-dialog-title">
        {userOnboardingState.matches("stepOne") && "Get Started with Real World App"}
        {userOnboardingState.matches("stepTwo") && "Create Bank Account"}
        {userOnboardingState.matches("stepThree") && "Finished"}
      </DialogTitle>
      <DialogContent data-test="user-onboarding-dialog-content">
        <Box display="flex" alignItems="center" justifyContent="center">
          {userOnboardingState.matches("stepOne") && (
            <>
              <NavigatorIllustration />
              <br />
              <DialogContentText style={{ paddingLeft: 20 }}>
                Real World App requires a Bank Account to perform transactions.
                <br />
                <br />
                Click <b>Next</b> to begin setup of your Bank Account.
              </DialogContentText>
            </>
          )}
          {userOnboardingState.matches("stepTwo") && (
            <BankAccountForm
              userId={currentUser?.id!}
              createBankAccount={createBankAccountWithNextStep}
              onboarding
            />
          )}
          {userOnboardingState.matches("stepThree") && (
            <>
              <PersonalFinance />
              <br />
              <DialogContentText style={{ paddingLeft: 20 }}>
                You're all set!
                <br />
                <br />
                We're excited to have you aboard the Real World App!
              </DialogContentText>
            </>
          )}
        </Box>
      </DialogContent>
      <DialogActions>
        <Grid container justify="space-between">
          <Grid item>
            <Button
              style={{ paddingRight: "80%" }}
              onClick={/* istanbul ignore next */ () => sendAuth("LOGOUT")}
              color="secondary"
              data-test="user-onboarding-logout"
            >
              Logout
            </Button>
          </Grid>
          <Grid item>
            {!userOnboardingState.matches("stepTwo") && (
              <Button onClick={() => nextStep()} color="primary" data-test="user-onboarding-next">
                {userOnboardingState.matches("stepThree") ? "Done" : "Next"}
              </Button>
            )}
          </Grid>
        </Grid>
      </DialogActions>
    </Dialog>
  );
};

export default UserOnboardingContainer;



================================================
FILE: cypress-realworld-app/src/containers/UserSettingsContainer.tsx
================================================
import React from "react";
import { makeStyles, Paper, Typography, Grid } from "@material-ui/core";
import UserSettingsForm from "../components/UserSettingsForm";
import { Interpreter } from "xstate";
import { AuthMachineContext, AuthMachineEvents } from "../machines/authMachine";
import { useService } from "@xstate/react";
import { ReactComponent as PersonalSettingsIllustration } from "../svgs/undraw_personal_settings_kihd.svg";

const useStyles = makeStyles((theme) => ({
  paper: {
    padding: theme.spacing(2),
    display: "flex",
    overflow: "auto",
    flexDirection: "column",
  },
}));

export interface Props {
  authService: Interpreter<AuthMachineContext, any, AuthMachineEvents, any>;
}

const UserSettingsContainer: React.FC<Props> = ({ authService }) => {
  const classes = useStyles();
  const [authState, sendAuth] = useService(authService);

  const currentUser = authState?.context?.user;
  const updateUser = (payload: any) => sendAuth("UPDATE", payload);

  return (
    <Paper className={classes.paper}>
      <Typography component="h2" variant="h6" color="primary" gutterBottom>
        User Settings
      </Typography>
      <Grid container spacing={2} direction="row" justify="flex-start" alignItems="flex-start">
        <Grid item>
          <PersonalSettingsIllustration style={{ height: 200, width: 300 }} />
        </Grid>
        <Grid item style={{ width: "50%" }}>
          {currentUser && <UserSettingsForm userProfile={currentUser} updateUser={updateUser} />}
        </Grid>
      </Grid>
    </Paper>
  );
};
export default UserSettingsContainer;



================================================
FILE: cypress-realworld-app/src/machines/authMachine.ts
================================================
import { Machine, assign, interpret, State } from "xstate";
import { omit } from "lodash/fp";
import { httpClient } from "../utils/asyncUtils";
import { history } from "../utils/historyUtils";
import { User } from "../models";

export interface AuthMachineSchema {
  states: {
    unauthorized: {};
    signup: {};
    loading: {};
    updating: {};
    logout: {};
    refreshing: {};
    authorized: {};
  };
}

export type AuthMachineEvents =
  | { type: "LOGIN" }
  | { type: "LOGOUT" }
  | { type: "UPDATE" }
  | { type: "REFRESH" }
  | { type: "SIGNUP" };

export interface AuthMachineContext {
  user?: User;
  message?: string;
}

export const authMachine = Machine<AuthMachineContext, AuthMachineSchema, AuthMachineEvents>(
  {
    id: "authentication",
    initial: "unauthorized",
    context: {
      user: undefined,
      message: undefined,
    },
    states: {
      unauthorized: {
        entry: "resetUser",
        on: {
          LOGIN: "loading",
          SIGNUP: "signup",
        },
      },
      signup: {
        invoke: {
          src: "performSignup",
          onDone: { target: "unauthorized", actions: "onSuccess" },
          onError: { target: "unauthorized", actions: "onError" },
        },
      },
      loading: {
        invoke: {
          src: "performLogin",
          onDone: { target: "authorized", actions: "onSuccess" },
          onError: { target: "unauthorized", actions: "onError" },
        },
      },
      updating: {
        invoke: {
          src: "updateProfile",
          onDone: { target: "refreshing" },
          onError: { target: "unauthorized", actions: "onError" },
        },
      },
      refreshing: {
        invoke: {
          src: "getUserProfile",
          onDone: { target: "authorized", actions: "setUserProfile" },
          onError: { target: "unauthorized", actions: "onError" },
        },
        on: {
          LOGOUT: "logout",
        },
      },
      logout: {
        invoke: {
          src: "performLogout",
          onDone: { target: "unauthorized" },
          onError: { target: "unauthorized", actions: "onError" },
        },
      },
      authorized: {
        entry: "redirectHomeAfterLogin",
        on: {
          UPDATE: "updating",
          REFRESH: "refreshing",
          LOGOUT: "logout",
        },
      },
    },
  },
  {
    services: {
      performSignup: async (ctx, event) => {
        const payload = omit("type", event);
        const resp = await httpClient.post(`http://localhost:3001/users`, payload);
        history.push("/signin");
        return resp.data;
      },
      performLogin: async (ctx, event) => {
        return await httpClient
          .post(`http://localhost:3001/login`, event)
          .then(({ data }) => {
            history.push("/");
            return data;
          })
          .catch((error) => {
            throw new Error("Username or password is invalid");
          });
      },
      getUserProfile: async (ctx, event) => {
        const resp = await httpClient.get(`http://localhost:3001/checkAuth`);
        return resp.data;
      },
      updateProfile: async (ctx, event: any) => {
        const payload = omit("type", event);
        const resp = await httpClient.patch(`http://localhost:3001/users/${payload.id}`, payload);
        return resp.data;
      },
      performLogout: async (ctx, event) => {
        localStorage.removeItem("authState");
        return await httpClient.post(`http://localhost:3001/logout`);
      },
    },
    actions: {
      redirectHomeAfterLogin: async (ctx, event) => {
        if (history.location.pathname === "/signin") {
          /* istanbul ignore next */
          window.location.pathname = "/";
        }
      },
      resetUser: assign((ctx: any, event: any) => ({
        user: undefined,
      })),
      setUserProfile: assign((ctx: any, event: any) => ({
        user: event.data.user,
      })),
      onSuccess: assign((ctx: any, event: any) => ({
        user: event.data.user,
        message: undefined,
      })),
      onError: assign((ctx: any, event: any) => ({
        message: event.data.message,
      })),
    },
  }
);

// @ts-ignore
const stateDefinition = JSON.parse(localStorage.getItem("authState"));

let resolvedState;
if (stateDefinition) {
  const previousState = State.create(stateDefinition);

  // @ts-ignore
  resolvedState = authMachine.resolveState(previousState);
}

export const authService = interpret(authMachine)
  .onTransition((state) => {
    if (state.changed) {
      localStorage.setItem("authState", JSON.stringify(state));
    }
  })
  .start(resolvedState);



================================================
FILE: cypress-realworld-app/src/machines/bankAccountsMachine.ts
================================================
import { isEmpty, omit } from "lodash/fp";
import { dataMachine } from "./dataMachine";
import { httpClient } from "../utils/asyncUtils";

export const bankAccountsMachine = dataMachine("bankAccounts").withConfig({
  services: {
    fetchData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.get(`http://localhost:3001/bankAccounts`, {
        params: !isEmpty(payload) && event.type === "FETCH" ? payload : undefined,
      });
      return resp.data;
    },
    deleteData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.delete(
        `http://localhost:3001/bankAccounts/${payload.id}`,
        payload
      );
      return resp.data;
    },
    createData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.post("http://localhost:3001/bankAccounts", payload);
      return resp.data;
    },
  },
});



================================================
FILE: cypress-realworld-app/src/machines/contactsTransactionsMachine.ts
================================================
import { dataMachine } from "./dataMachine";
import { httpClient } from "../utils/asyncUtils";
import { isEmpty, omit } from "lodash/fp";

export const contactsTransactionsMachine = dataMachine("contactsTransactions").withConfig({
  services: {
    fetchData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.get(`http://localhost:3001/transactions/contacts`, {
        params: !isEmpty(payload) ? payload : undefined,
      });
      return resp.data;
    },
  },
});



================================================
FILE: cypress-realworld-app/src/machines/createTransactionMachine.ts
================================================
import { omit } from "lodash/fp";
import { Machine, assign } from "xstate";
import { dataMachine } from "./dataMachine";
import { httpClient } from "../utils/asyncUtils";
import { User, TransactionCreatePayload } from "../models";
import { authService } from "./authMachine";

export interface CreateTransactionMachineSchema {
  states: {
    stepOne: {};
    stepTwo: {};
    stepThree: {};
  };
}

const transactionDataMachine = dataMachine("transactionData").withConfig({
  services: {
    createData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.post(`http://localhost:3001/transactions`, payload);
      authService.send("REFRESH");
      return resp.data;
    },
  },
});

export type CreateTransactionMachineEvents =
  | { type: "SET_USERS" }
  | { type: "CREATE" }
  | { type: "RESET" };

export interface CreateTransactionMachineContext {
  sender: User;
  receiver: User;
  transactionDetails: TransactionCreatePayload;
}

export const createTransactionMachine = Machine<
  CreateTransactionMachineContext,
  CreateTransactionMachineSchema,
  CreateTransactionMachineEvents
>(
  {
    id: "createTransaction",
    initial: "stepOne",
    states: {
      stepOne: {
        entry: "clearContext",
        on: {
          SET_USERS: "stepTwo",
        },
      },
      stepTwo: {
        entry: "setSenderAndReceiver",
        invoke: {
          id: "transactionDataMachine",
          src: transactionDataMachine,
          autoForward: true,
        },
        on: {
          CREATE: "stepThree",
        },
      },
      stepThree: {
        entry: "setTransactionDetails",
        on: {
          RESET: "stepOne",
        },
      },
    },
  },
  {
    actions: {
      setSenderAndReceiver: assign((ctx, event: any) => ({
        sender: event.sender,
        receiver: event.receiver,
      })),
      setTransactionDetails: assign((ctx, event: any) => ({
        transactionDetails: event,
      })),
      clearContext: assign((ctx, event: any) => ({})),
    },
  }
);



================================================
FILE: cypress-realworld-app/src/machines/dataMachine.ts
================================================
import { Machine, assign } from "xstate";
import { concat } from "lodash/fp";

export interface DataSchema {
  states: {
    idle: {};
    loading: {};
    updating: {};
    creating: {};
    deleting: {};
    success: {
      states: {
        unknown: {};
        withData: {};
        withoutData: {};
      };
    };
    failure: {};
  };
}

type SuccessEvent = { type: "SUCCESS"; results: any[]; pageData: object };
type FailureEvent = { type: "FAILURE"; message: string };
export type DataEvents =
  | { type: "FETCH" }
  | { type: "UPDATE" }
  | { type: "CREATE" }
  | { type: "DELETE" }
  | SuccessEvent
  | FailureEvent;

export interface DataContext {
  pageData?: object;
  results?: any[];
  message?: string;
}

export const dataMachine = (machineId: string) =>
  Machine<DataContext, DataSchema, DataEvents>(
    {
      id: machineId,
      initial: "idle",
      context: {
        pageData: {},
        results: [],
        message: undefined,
      },
      states: {
        idle: {
          on: {
            FETCH: "loading",
            CREATE: "creating",
            UPDATE: "updating",
            DELETE: "deleting",
          },
        },
        loading: {
          invoke: {
            src: "fetchData",
            onDone: { target: "success" },
            onError: { target: "failure", actions: "setMessage" },
          },
        },
        updating: {
          invoke: {
            src: "updateData",
            onDone: { target: "loading" },
            onError: { target: "failure", actions: "setMessage" },
          },
        },
        creating: {
          invoke: {
            src: "createData",
            onDone: { target: "loading" },
            onError: { target: "failure", actions: "setMessage" },
          },
        },
        deleting: {
          invoke: {
            src: "deleteData",
            onDone: { target: "loading" },
            onError: { target: "failure", actions: "setMessage" },
          },
        },
        success: {
          entry: ["setResults", "setPageData"],
          on: {
            FETCH: "loading",
            CREATE: "creating",
            UPDATE: "updating",
            DELETE: "deleting",
          },
          initial: "unknown",
          states: {
            unknown: {
              on: {
                "": [{ target: "withData", cond: "hasData" }, { target: "withoutData" }],
              },
            },
            withData: {},
            withoutData: {},
          },
        },
        failure: {
          entry: ["setMessage"],
          on: {
            FETCH: "loading",
          },
        },
      },
    },
    {
      actions: {
        setResults: assign((ctx: DataContext, event: any) => ({
          results:
            event.data && event.data.pageData && event.data.pageData.page > 1
              ? concat(ctx.results, event.data.results)
              : event.data.results,
        })),
        setPageData: assign((ctx: DataContext, event: any) => ({
          pageData: event.data.pageData,
        })),

        setMessage: /* istanbul ignore next */ assign((ctx, event: any) => ({
          message: event.message,
        })),
      },
      guards: {
        hasData: (ctx: DataContext, event) => !!ctx.results && ctx.results.length > 0,
      },
    }
  );



================================================
FILE: cypress-realworld-app/src/machines/drawerMachine.ts
================================================
import { Machine } from "xstate";

export const drawerMachine = Machine(
  {
    id: "drawer",
    type: "parallel",
    states: {
      desktop: {
        initial: "open",
        states: {
          closed: {
            on: {
              TOGGLE_DESKTOP: "open",
              OPEN_DESKTOP: { target: "open", cond: "shouldOpenDesktop" },
            },
          },
          open: {
            on: { TOGGLE_DESKTOP: "closed", CLOSE_DESKTOP: "closed" },
          },
          hist: {
            type: "history",
          },
        },
      },
      mobile: {
        initial: "closed",
        states: {
          closed: {
            on: { TOGGLE_MOBILE: "open", OPEN_MOBILE: "open" },
          },
          open: {
            on: { TOGGLE_MOBILE: "closed", CLOSE_MOBILE: "closed" },
          },
        },
      },
    },
  },
  {
    guards: {
      shouldOpenDesktop: (context, event, guardMeta) => {
        return (
          guardMeta.state.history?.context.aboveSmallBreakpoint !== context.aboveSmallBreakpoint
        );
      },
    },
  }
);



================================================
FILE: cypress-realworld-app/src/machines/notificationsMachine.ts
================================================
import { isEmpty, omit } from "lodash/fp";
import { dataMachine } from "./dataMachine";
import { httpClient } from "../utils/asyncUtils";

export const notificationsMachine = dataMachine("notifications").withConfig({
  services: {
    fetchData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.get(`http://localhost:3001/notifications`, {
        params: !isEmpty(payload) && event.type === "FETCH" ? payload : undefined,
      });
      return resp.data;
    },
    updateData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.patch(
        `http://localhost:3001/notifications/${payload.id}`,
        payload
      );
      return resp.data;
    },
  },
});



================================================
FILE: cypress-realworld-app/src/machines/personalTransactionsMachine.ts
================================================
import { dataMachine } from "./dataMachine";
import { httpClient } from "../utils/asyncUtils";
import { isEmpty, omit } from "lodash/fp";

export const personalTransactionsMachine = dataMachine("personalTransactions").withConfig({
  services: {
    fetchData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.get(`http://localhost:3001/transactions`, {
        params: !isEmpty(payload) ? payload : undefined,
      });
      return resp.data;
    },
  },
});



================================================
FILE: cypress-realworld-app/src/machines/publicTransactionsMachine.ts
================================================
import { dataMachine } from "./dataMachine";
import { httpClient } from "../utils/asyncUtils";
import { isEmpty, omit } from "lodash/fp";

export const publicTransactionsMachine = dataMachine("publicTransactions").withConfig({
  services: {
    fetchData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const resp = await httpClient.get(`http://localhost:3001/transactions/public`, {
        params: !isEmpty(payload) ? payload : undefined,
      });
      return resp.data;
    },
  },
});



================================================
FILE: cypress-realworld-app/src/machines/snackbarMachine.ts
================================================
import { Machine, assign } from "xstate";

export interface SnackbarSchema {
  states: {
    invisible: {};
    visible: {};
  };
}

export type SnackbarEvents = { type: "SHOW" } | { type: "HIDE" };

export interface SnackbarContext {
  severity?: "success" | "info" | "warning" | "error";
  message?: string;
}

export const snackbarMachine = Machine<SnackbarContext, SnackbarSchema, SnackbarEvents>(
  {
    id: "snackbar",
    initial: "invisible",
    context: {
      severity: undefined,
      message: undefined,
    },
    states: {
      invisible: {
        entry: "resetSnackbar",
        on: { SHOW: "visible" },
      },
      visible: {
        entry: "setSnackbar",
        on: { HIDE: "invisible" },
        after: {
          // after 5 seconds, transition to invisible
          3000: "invisible",
        },
      },
    },
  },
  {
    actions: {
      setSnackbar: assign((ctx, event: any) => ({
        severity: event.severity,
        message: event.message,
      })),
      resetSnackbar: assign((ctx, event: any) => ({
        severity: undefined,
        message: undefined,
      })),
    },
  }
);



================================================
FILE: cypress-realworld-app/src/machines/transactionDetailMachine.ts
================================================
import { omit, flow, first, isEmpty } from "lodash/fp";
import { dataMachine } from "./dataMachine";
import { httpClient } from "../utils/asyncUtils";

export const transactionDetailMachine = dataMachine("transactionData").withConfig({
  services: {
    fetchData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const contextTransactionId = !isEmpty(ctx.results) && first(ctx.results)["id"];
      const transactionId = contextTransactionId || payload.transactionId;
      const resp = await httpClient.get(`http://localhost:3001/transactions/${transactionId}`);
      return { results: [resp.data.transaction] };
    },
    createData: async (ctx, event: any) => {
      let route = event.entity === "LIKE" ? "likes" : "comments";
      const payload = flow(omit("type"), omit("entity"))(event);
      const resp = await httpClient.post(
        `http://localhost:3001/${route}/${payload.transactionId}`,
        payload
      );
      return resp.data;
    },
    updateData: async (ctx, event: any) => {
      const payload = omit("type", event);
      const contextTransactionId = !isEmpty(ctx.results) && first(ctx.results)["id"];
      const transactionId = contextTransactionId || payload.id;
      const resp = await httpClient.patch(
        `http://localhost:3001/transactions/${transactionId}`,
        payload
      );
      return resp.data;
    },
  },
});



================================================
FILE: cypress-realworld-app/src/machines/transactionFiltersMachine.ts
================================================
import { Machine, assign } from "xstate";

interface FilterSchema {
  states: {
    dateRange: {
      states: {
        none: {};
        filter: {};
      };
    };
    amountRange: {
      states: {
        none: {};
        filter: {};
      };
    };
  };
}

type DateFilterEvent = {
  type: "DATE_FILTER";
  dateRangeStart: string;
  dateRangeEnd: string;
};
type AmountFilterEvent = {
  type: "AMOUNT_FILTER";
  amountMin: string;
  amountMax: string;
};
type DateResetEvent = { type: "DATE_RESET" };
type AmountResetEvent = { type: "AMOUNT_RESET" };
type FilterEvents =
  | { type: "NONE" }
  | DateFilterEvent
  | AmountFilterEvent
  | DateResetEvent
  | AmountResetEvent;

export interface FilterContext {}

export const transactionFiltersMachine = Machine<FilterContext, FilterSchema, FilterEvents>(
  {
    id: "filters",
    type: "parallel",
    context: {},
    states: {
      dateRange: {
        initial: "none",
        states: {
          none: {
            entry: "resetDateRange",
            on: {
              DATE_FILTER: "filter",
            },
          },
          filter: {
            entry: "setDateRange",
            on: {
              DATE_RESET: "none",
            },
          },
        },
      },
      amountRange: {
        initial: "none",
        states: {
          none: {
            entry: "resetAmountRange",
            on: {
              AMOUNT_FILTER: "filter",
            },
          },
          filter: {
            entry: "setAmountRange",
            on: {
              AMOUNT_RESET: "none",
              AMOUNT_FILTER: "filter",
            },
          },
        },
      },
    },
  },
  {
    actions: {
      setDateRange: assign((ctx: FilterContext, event: any) => ({
        dateRangeStart: event.dateRangeStart,
        dateRangeEnd: event.dateRangeEnd,
      })),
      resetDateRange: assign((ctx: FilterContext, event: any) => ({
        dateRangeStart: undefined,
        dateRangeEnd: undefined,
      })),
      setAmountRange: assign((ctx: FilterContext, event: any) => ({
        amountMin: event.amountMin,
        amountMax: event.amountMax,
      })),
      resetAmountRange: assign((ctx: FilterContext, event: any) => ({
        amountMin: undefined,
        amountMax: undefined,
      })),
    },
  }
);



================================================
FILE: cypress-realworld-app/src/machines/userOnboardingMachine.ts
================================================
import { Machine } from "xstate";

export interface UserOnboardingMachineSchema {
  states: {
    idle: {};
    stepOne: {};
    stepTwo: {};
    stepThree: {};
    done: {};
  };
}

export type UserOnboardingMachineEvents = { type: "PREV" } | { type: "NEXT" };

export interface UserOnboardingMachineContext {}

export const userOnboardingMachine = Machine<
  UserOnboardingMachineContext,
  UserOnboardingMachineSchema,
  UserOnboardingMachineEvents
>({
  id: "userOnboarding",
  initial: "stepOne",
  states: {
    idle: {
      on: {
        NEXT: "stepOne",
      },
    },
    stepOne: {
      on: {
        NEXT: "stepTwo",
      },
    },
    stepTwo: {
      on: {
        PREV: "stepOne",
        NEXT: "stepThree",
      },
    },
    stepThree: {
      on: {
        PREV: "stepTwo",
        NEXT: "done",
      },
    },
    done: {
      type: "final",
    },
  },
});



================================================
FILE: cypress-realworld-app/src/machines/usersMachine.ts
================================================
import { isEmpty, omit } from "lodash/fp";
import { dataMachine } from "./dataMachine";
import { httpClient } from "../utils/asyncUtils";

export const usersMachine = dataMachine("users").withConfig({
  services: {
    fetchData: async (ctx, event: any) => {
      const payload = omit("type", event);
      let route = isEmpty(payload) ? "users" : "users/search";
      const resp = await httpClient.get(`http://localhost:3001/${route}`, {
        params: !isEmpty(payload) ? payload : undefined,
      });
      return resp.data;
    },
  },
});



================================================
FILE: cypress-realworld-app/src/models/bankaccount.ts
================================================
export interface BankAccount {
  id: string;
  uuid: string;
  userId: string;
  bankName: string;
  accountNumber: string;
  routingNumber: string;
  isDeleted: boolean;
  createdAt: Date;
  modifiedAt: Date;
}

export type BankAccountPayload = Pick<
  BankAccount,
  "userId" | "bankName" | "accountNumber" | "routingNumber"
>;



================================================
FILE: cypress-realworld-app/src/models/banktransfer.ts
================================================
export enum BankTransferType {
  withdrawal = "withdrawal",
  deposit = "deposit",
}
export interface BankTransfer {
  id: string;
  uuid: string;
  userId: string;
  source: string;
  amount: number;
  type: BankTransferType;
  transactionId: string;
  createdAt: Date;
  modifiedAt: Date;
}
export type BankTransferPayload = Omit<BankTransfer, "id" | "uuid" | "createdAt" | "modifiedAt">;



================================================
FILE: cypress-realworld-app/src/models/comment.ts
================================================
export interface Comment {
  id: string;
  uuid: string;
  content: string;
  userId: string;
  transactionId: string;
  createdAt: Date;
  modifiedAt: Date;
}



================================================
FILE: cypress-realworld-app/src/models/contact.ts
================================================
export interface Contact {
  id: string;
  uuid: string;
  userId: string;
  contactUserId: string;
  createdAt: Date;
  modifiedAt: Date;
}



================================================
FILE: cypress-realworld-app/src/models/db-schema.ts
================================================
import { User } from "./user";
import { Contact } from "./contact";
import { BankAccount } from "./bankaccount";
import { Transaction } from "./transaction";
import { Like } from "./like";
import { BankTransfer } from "./banktransfer";
import { NotificationType } from "./notification";
import { Comment } from "./comment";

export interface DbSchema {
  users: User[];
  contacts: Contact[];
  bankaccounts: BankAccount[];
  transactions: Transaction[];
  likes: Like[];
  comments: Comment[];
  notifications: NotificationType[];
  banktransfers: BankTransfer[];
}



================================================
FILE: cypress-realworld-app/src/models/index.ts
================================================
export * from "./user";
export * from "./bankaccount";
export * from "./contact";
export * from "./transaction";
export * from "./like";
export * from "./comment";
export * from "./notification";
export * from "./banktransfer";



================================================
FILE: cypress-realworld-app/src/models/like.ts
================================================
export interface Like {
  id: string;
  uuid: string;
  userId: string;
  transactionId: string;
  createdAt: Date;
  modifiedAt: Date;
}



================================================
FILE: cypress-realworld-app/src/models/notification.ts
================================================
export enum PaymentNotificationStatus {
  requested = "requested",
  received = "received",
  incomplete = "incomplete",
}

export enum NotificationsType {
  payment = "payment",
  like = "like",
  comment = "comment",
}

export interface NotificationBase {
  id: string;
  uuid: string;
  userId: string;
  transactionId: string;
  isRead: boolean;
  createdAt: Date;
  modifiedAt: Date;
}

export type NotificationUpdatePayload = Partial<Pick<NotificationBase, "id" | "isRead">>;

export interface PaymentNotification extends NotificationBase {
  status: PaymentNotificationStatus;
}

export interface LikeNotification extends NotificationBase {
  likeId: string;
}

export interface CommentNotification extends NotificationBase {
  commentId: string;
}

export interface PaymentNotificationResponseItem extends PaymentNotification {
  userFullName: string;
}

export interface CommentNotificationResponseItem extends CommentNotification {
  userFullName: string;
}

export interface LikeNotificationResponseItem extends LikeNotification {
  userFullName: string;
}

export interface NotificationPayloadBase {
  type: NotificationsType;
  transactionId: string;
}

export interface PaymentNotificationPayload extends NotificationPayloadBase {
  status: PaymentNotificationStatus;
}

export interface LikeNotificationPayload extends NotificationPayloadBase {
  likeId: string;
}

export interface CommentNotificationPayload extends NotificationPayloadBase {
  commentId: string;
}

export type NotificationType = PaymentNotification | LikeNotification | CommentNotification;

export type NotificationPayloadType =
  | PaymentNotificationPayload
  | LikeNotificationPayload
  | CommentNotificationPayload;

export type NotificationResponseItem =
  | PaymentNotificationResponseItem
  | LikeNotificationResponseItem
  | CommentNotificationResponseItem;



================================================
FILE: cypress-realworld-app/src/models/transaction.ts
================================================
import { DefaultPrivacyLevel } from "./user";
import { Like, Comment } from ".";

export enum TransactionStatus {
  pending = "pending",
  incomplete = "incomplete",
  complete = "complete",
}

export enum TransactionRequestStatus {
  pending = "pending",
  accepted = "accepted",
  rejected = "rejected",
}

export interface Transaction {
  id: string;
  uuid: string;
  source: string; // Empty if Payment or Request; Populated with BankAccount ID
  amount: number;
  description: string;
  privacyLevel: DefaultPrivacyLevel;
  receiverId: string;
  senderId: string;
  balanceAtCompletion?: number;
  status: TransactionStatus;
  requestStatus?: TransactionRequestStatus | string;
  requestResolvedAt?: Date | string;
  createdAt: Date;
  modifiedAt: Date;
}

export interface FakeTransaction {
  id?: string;
  uuid?: string;
  source?: string; // Empty if Payment or Request; Populated with BankAccount ID
  amount?: number;
  description?: string;
  privacyLevel?: DefaultPrivacyLevel;
  receiverId: string;
  senderId: string;
  balanceAtCompletion?: number;
  status?: TransactionStatus;
  requestStatus?: TransactionRequestStatus | string;
  requestResolvedAt?: Date | string;
  createdAt?: Date;
  modifiedAt?: Date;
}

export interface TransactionResponseItem extends Transaction {
  likes: Like[];
  comments: Comment[];
  receiverName: string;
  receiverAvatar: string;
  senderName: string;
  senderAvatar: string;
}

export type TransactionScenario = {
  status: TransactionStatus;
  requestStatus: TransactionRequestStatus | string;
};

export type TransactionPayload = Omit<Transaction, "id" | "uuid" | "createdAt" | "modifiedAt">;

export type TransactionCreatePayload = Partial<
  Pick<Transaction, "senderId" | "receiverId" | "description"> & {
    amount: string;
    transactionType: string;
  }
>;

export type TransactionUpdateActionPayload = Pick<Transaction, "id" | "requestStatus">;

type TransactionQueryBase = {
  dateRangeStart?: string;
  dateRangeEnd?: string;
  amountMin?: number;
  amountMax?: number;
  status?: TransactionStatus;
  limit?: number;
  page?: number;
};

export type TransactionQueryPayload = Partial<TransactionQueryBase>;

export type TransactionDateRangePayload = Partial<
  Pick<TransactionQueryPayload, "dateRangeStart" | "dateRangeEnd">
>;

export type TransactionAmountRangePayload = Partial<
  Pick<TransactionQueryPayload, "amountMin" | "amountMax">
>;

export type TransactionPaginationPayload = Partial<Pick<TransactionQueryPayload, "page" | "limit">>;

export type TransactionClearFiltersPayload = {
  filterType: "date" | "amount";
};

export type TransactionPagination = {
  page: number;
  limit: number;
  hasNextPages: boolean;
  totalPages: number;
};



================================================
FILE: cypress-realworld-app/src/models/user.ts
================================================
export enum DefaultPrivacyLevel {
  public = "public",
  private = "private",
  contacts = "contacts",
}

export interface User {
  id: string;
  uuid: string;
  firstName: string;
  lastName: string;
  username: string;
  password: string;
  email: string;
  phoneNumber: string;
  balance: number;
  avatar: string;
  defaultPrivacyLevel: DefaultPrivacyLevel;
  createdAt: Date;
  modifiedAt: Date;
}

export type UserSettingsPayload = Pick<
  User,
  "firstName" | "lastName" | "email" | "phoneNumber" | "defaultPrivacyLevel"
>;

export type SignInPayload = Pick<User, "username" | "password"> & {
  remember?: Boolean;
};

export type SignUpPayload = Pick<User, "username" | "password" | "firstName" | "lastName">;



================================================
FILE: cypress-realworld-app/src/utils/asyncUtils.ts
================================================
import axios from "axios";

export const httpClient = axios.create({ withCredentials: true });



================================================
FILE: cypress-realworld-app/src/utils/historyUtils.ts
================================================
import { createBrowserHistory } from "history";

export const history = createBrowserHistory();



================================================
FILE: cypress-realworld-app/src/utils/transactionUtils.ts
================================================
import {
  Transaction,
  User,
  TransactionRequestStatus,
  NotificationType,
  PaymentNotificationStatus,
  TransactionResponseItem,
  TransactionQueryPayload,
  TransactionDateRangePayload,
  TransactionAmountRangePayload,
  LikeNotification,
  CommentNotification,
} from "../models";
import faker from "faker";
import Dinero from "dinero.js";
import {
  flow,
  get,
  isEmpty,
  negate,
  curry,
  isEqual,
  join,
  pick,
  values,
  has,
  find,
  omit,
  map,
  drop,
} from "lodash/fp";

export const isRequestTransaction = (transaction: Transaction) =>
  flow(get("requestStatus"), negate(isEmpty))(transaction);

/* istanbul ignore next */
export const isPendingRequestTransaction = (transaction: Transaction) =>
  flow(get("requestStatus"), isEqual(TransactionRequestStatus.pending))(transaction);

/* istanbul ignore next */
export const isAcceptedRequestTransaction = (transaction: Transaction) =>
  flow(get("requestStatus"), isEqual(TransactionRequestStatus.accepted))(transaction);

/* istanbul ignore next */
export const isRejectedRequestTransaction = (transaction: Transaction) =>
  flow(get("requestStatus"), isEqual(TransactionRequestStatus.rejected))(transaction);

export const isPayment = negate(isRequestTransaction);

/* istanbul ignore next */
export const getFakeAmount = (min: number = 1000, max: number = 50000) =>
  parseInt(faker.finance.amount(min, max), 10);

/* istanbul ignore next */
export const formatAmount = (amount: number) => Dinero({ amount }).toFormat();

/* istanbul ignore next */
export const formatAmountSlider = (amount: number) => Dinero({ amount }).toFormat("$0,0");

export const payAppDifference = curry((sender: User, transaction: Transaction) =>
  Dinero({ amount: get("balance", sender) }).subtract(
    Dinero({ amount: get("amount", transaction) })
  )
);

export const payAppAddition = curry((sender: User, transaction: Transaction) =>
  Dinero({ amount: get("balance", sender) }).add(Dinero({ amount: get("amount", transaction) }))
);

export const getChargeAmount = (sender: User, transaction: Transaction) =>
  Math.abs(payAppDifference(sender, transaction).getAmount());

export const getTransferAmount = curry((sender: User, transaction: Transaction) =>
  Math.abs(payAppDifference(sender, transaction).getAmount())
);

export const getPayAppCreditedAmount = (receiver: User, transaction: Transaction) =>
  Math.abs(payAppAddition(receiver, transaction).getAmount());

export const hasSufficientFunds = (sender: User, transaction: Transaction) =>
  payAppDifference(sender, transaction).isPositive();

/* istanbul ignore next */
export const receiverIsCurrentUser = (currentUser: User, transaction: Transaction) =>
  isEqual(get("id", currentUser), get("receiverId", transaction));

export const formatFullName = (user: User) =>
  flow(pick(["firstName", "lastName"]), values, join(" "))(user);

export const isCommentNotification = (
  notification: NotificationType
): notification is CommentNotification => has("commentId")(notification);

export const isLikeNotification = (
  notification: NotificationType
): notification is LikeNotification => has("likeId")(notification);

export const isPaymentNotification = (notification: NotificationType) =>
  has("status")(notification);

/* istanbul ignore next */
export const isPaymentRequestedNotification = (notification: NotificationType) =>
  flow(get("status"), isEqual(PaymentNotificationStatus.requested))(notification);

/* istanbul ignore next */
export const isPaymentReceivedNotification = (notification: NotificationType) =>
  flow(get("status"), isEqual(PaymentNotificationStatus.received))(notification);

/* istanbul ignore next */
export const currentUserLikesTransaction = (
  currentUser: User,
  transaction: TransactionResponseItem
) =>
  flow(
    find((like) => flow(get("userId"), isEqual(get("id", currentUser)))(like)),
    negate(isEmpty)
  )(transaction.likes);

export const hasDateQueryFields = (query: TransactionQueryPayload | TransactionDateRangePayload) =>
  has("dateRangeStart", query) && has("dateRangeEnd", query);

export const getDateQueryFields = (query: TransactionDateRangePayload) =>
  pick(["dateRangeStart", "dateRangeEnd"], query);

export const omitDateQueryFields = (query: TransactionQueryPayload) =>
  omit(["dateRangeStart", "dateRangeEnd"], query);

export const hasAmountQueryFields = (
  query: TransactionQueryPayload | TransactionAmountRangePayload
) => has("amountMin", query) && has("amountMax", query);

export const getAmountQueryFields = (query: TransactionAmountRangePayload) =>
  pick(["amountMin", "amountMax"], query);

export const omitAmountQueryFields = (query: TransactionQueryPayload) =>
  omit(["amountMin", "amountMax"], query);

/* istanbul ignore next */
export const hasPaginationQueryFields = (
  query: TransactionQueryPayload | TransactionAmountRangePayload
) => has("page", query) && has("limit", query);

export const omitPaginationQueryFields = (query: TransactionQueryPayload) =>
  omit(["page", "limit"], query);

/* istanbul ignore next */
export const getQueryWithoutDateFields = (query: TransactionQueryPayload) =>
  query && hasDateQueryFields(query) ? omitDateQueryFields(query) : query;

/* istanbul ignore next */
export const getQueryWithoutAmountFields = (query: TransactionQueryPayload) =>
  query && hasAmountQueryFields(query) ? omitAmountQueryFields(query) : query;

export const getQueryWithoutFilterFields = (query: TransactionQueryPayload) =>
  flow(omitAmountQueryFields, omitDateQueryFields, omitPaginationQueryFields)(query);

/* istanbul ignore next */
export const padAmountWithZeros = (number: number) => Math.ceil(number * 1000);

/* istanbul ignore next */
export const amountRangeValueText = (value: number) =>
  flow(padAmountWithZeros, formatAmount)(value);

/* istanbul ignore next */
export const amountRangeValueTextLabel = (value: number) =>
  /* istanbul ignore next */
  flow(padAmountWithZeros, formatAmountSlider)(value);

/* istanbul ignore next */
export const formatAmountRangeValues = (amountRangeValues: number[]) =>
  /* istanbul ignore next */
  flow(map(padAmountWithZeros), map(formatAmountSlider), join(" - "))(amountRangeValues);

export const getPaginatedItems = (page: number, limit: number, items: any) => {
  const offset = (page - 1) * limit;
  const pagedItems = drop(offset, items).slice(0, limit);

  return {
    totalPages: Math.ceil(items.length / limit),
    data: pagedItems,
  };
};

// Custom UTC functions per:
// https://github.com/date-fns/date-fns/issues/376#issuecomment-544274031
// not used in application code
/* istanbul ignore next */
export const startOfDayUTC = (date: Date) => new Date(new Date(date).setUTCHours(0, 0, 0, 0));

// not used in application code
/* istanbul ignore next */
export const endOfDayUTC = (date: Date) => new Date(new Date(date).setUTCHours(23, 59, 59, 999));



================================================
FILE: cypress-realworld-app/src/utils/__tests__/transactionUtils.test.ts
================================================
import {
  isRequestTransaction,
  getFakeAmount,
  currentUserLikesTransaction,
  getQueryWithoutDateFields,
  getQueryWithoutAmountFields,
  getQueryWithoutFilterFields,
} from "../transactionUtils";
import faker from "faker";
import {
  Transaction,
  TransactionRequestStatus,
  DefaultPrivacyLevel,
  TransactionStatus,
  TransactionResponseItem,
} from "../../models";
import shortid from "shortid";

const fakeTransaction = (
  requestStatus?: TransactionRequestStatus,
  createdAt?: Date
): Transaction => ({
  id: shortid(),
  uuid: faker.random.uuid(),
  source: shortid(),
  amount: getFakeAmount(),
  description: "food",
  privacyLevel: DefaultPrivacyLevel.public,
  receiverId: shortid(),
  senderId: shortid(),
  balanceAtCompletion: getFakeAmount(),
  status: TransactionStatus.pending,
  requestStatus,
  requestResolvedAt: faker.date.future(),
  createdAt: faker.date.past(),
  modifiedAt: createdAt || faker.date.recent(),
});

describe("Transaction Utils", () => {
  describe("isRequestTransaction", () => {
    let transaction;

    test("validates that a transaction is a request", () => {
      for (let s in TransactionRequestStatus) {
        transaction = fakeTransaction(s as TransactionRequestStatus);
        expect(isRequestTransaction(transaction)).toBeTruthy();
      }
    });

    test("validates that a transaction is not a request", () => {
      transaction = fakeTransaction();
      expect(isRequestTransaction(transaction)).toBe(false);
    });

    test("checks if the current user likes a transaction", () => {
      const transactionBase = fakeTransaction();

      const currentUser = {
        id: "9IUK0xpw",
        uuid: faker.random.uuid(),
        firstName: faker.name.firstName(),
        lastName: faker.name.lastName(),
        username: faker.internet.userName(),
        password: "abc123",
        email: faker.internet.email(),
        phoneNumber: faker.phone.phoneNumber(),
        avatar: faker.internet.avatar(),
        defaultPrivacyLevel: DefaultPrivacyLevel.public,
        balance: faker.random.number(),
        createdAt: faker.date.past(),
        modifiedAt: faker.date.recent(),
      };

      const transactionWithLikes: TransactionResponseItem = {
        ...transactionBase,
        receiverName: "Receiver Name",
        receiverAvatar: "/path/to/receiver/avatar.png",
        senderAvatar: "/path/to/sender/avatar.png",
        senderName: "Sender Name",
        likes: [
          {
            id: "ExVksKSH",
            uuid: "c849329f-42f7-4ff5-a792-e01c9cec05b5",
            userId: "9IUK0xpw",
            transactionId: "dKAI-6Ua",
            createdAt: new Date(),
            modifiedAt: new Date(),
          },
        ],
        comments: [],
      };

      expect(currentUserLikesTransaction(currentUser, transactionWithLikes)).toBe(true);

      const otherCurrentUser = {
        ...currentUser,
        id: "ABC123",
      };

      expect(currentUserLikesTransaction(otherCurrentUser, transactionWithLikes)).toBe(false);
    });
  });

  test("gets query without date range fields", () => {
    expect(
      getQueryWithoutDateFields({
        dateRangeStart: new Date().toString(),
        dateRangeEnd: new Date().toString(),
        status: TransactionStatus.incomplete,
      })
    ).toMatchObject({ status: "incomplete" });
    expect(
      getQueryWithoutDateFields({
        status: TransactionStatus.incomplete,
      })
    ).toMatchObject({ status: "incomplete" });
  });

  test("gets query without amount range fields", () => {
    expect(
      getQueryWithoutAmountFields({
        amountMin: 5,
        amountMax: 10,
        status: TransactionStatus.incomplete,
      })
    ).toMatchObject({ status: "incomplete" });
    expect(
      getQueryWithoutAmountFields({
        status: TransactionStatus.incomplete,
      })
    ).toMatchObject({ status: "incomplete" });
  });

  test("gets query without date and amount range fields", () => {
    const query = {
      amountMin: 5,
      amountMax: 10,
      requestStatus: "pending",
      dateRangeStart: "2019-12-01T06:00:00.000Z",
      dateRangeEnd: "2019-12-05T06:00:00.000Z",
    };
    expect(getQueryWithoutFilterFields(query)).toMatchObject({
      requestStatus: "pending",
    });
  });
});



================================================
FILE: cypress-realworld-app/.circleci/config.yml
================================================
version: 2.1
orbs:
  cypress: cypress-io/cypress@1.26.0
  codecov: codecov/codecov@1.1.1
  win: circleci/windows@2.4.0

executors:
  with-chrome-and-firefox:
    docker:
      - image: "cypress/browsers:node12.18.0-chrome83-ff77"

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Commands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
commands:
  report-coverage:
    description: |
      Store coverage report as an artifact and send it to Codecov service.
    steps:
      - store_artifacts:
          path: coverage
      - run: npx nyc report --reporter=text || true
      - codecov/upload:
          file: coverage/coverage-final.json

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Workflows ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
linux-workflow: &linux-workflow
  jobs:
    # Setup
    #  1. Install Cypress
    #  2. Validate types
    #  3. Run server unit-tests
    - cypress/install:
        name: "Setup Linux"
        yarn: true
        executor: with-chrome-and-firefox
        post-steps:
          - run:
              name: Check Types
              command: yarn types
          - run:
              name: Run Unit Tests
              command: yarn test:unit:ci

    # Run API tests against backend server
    - cypress/run:
        name: "API Tests"
        browser: chrome
        spec: cypress/tests/api/*
        executor: with-chrome-and-firefox
        wait-on: "http://localhost:3000"
        yarn: true
        start: yarn start:ci
        record: true
        parallel: true
        parallelism: 5
        ci-build-id: ${CIRCLE_SHA1:0:8}
        group: API
        requires:
          - Setup Linux
        post-steps:
          - report-coverage

    # Run E2E tests in Chrome
    - cypress/run:
        name: "UI Tests - Chrome"
        browser: chrome
        spec: cypress/tests/ui/*
        executor: with-chrome-and-firefox
        wait-on: "http://localhost:3000"
        command-prefix: npx percy exec --
        yarn: true
        start: yarn start:ci
        record: true
        parallel: true
        parallelism: 5
        ci-build-id: ${CIRCLE_SHA1:0:8}
        group: "UI - Chrome"
        requires:
          - Setup Linux
        post-steps:
          - report-coverage

    # Run E2E tests in Chrome with mobile device viewport
    - cypress/run:
        name: "UI Tests - Chrome - Mobile"
        browser: chrome
        spec: cypress/tests/ui/*
        config: "viewportWidth=375,viewportHeight=667"
        executor: with-chrome-and-firefox
        wait-on: "http://localhost:3000"
        yarn: true
        start: yarn start:ci
        record: true
        parallel: true
        parallelism: 5
        ci-build-id: ${CIRCLE_SHA1:0:8}
        group: "UI - Chrome - Mobile"
        requires:
          - Setup Linux
        post-steps:
          - report-coverage

    # Run E2E tests in Firefox
    - cypress/run:
        name: "UI Tests - Firefox"
        browser: firefox
        spec: cypress/tests/ui/*
        executor: with-chrome-and-firefox
        wait-on: "http://localhost:3000"
        yarn: true
        start: yarn start:ci
        record: true
        parallel: true
        parallelism: 5
        ci-build-id: ${CIRCLE_SHA1:0:8}
        group: "UI - Firefox"
        requires:
          - Setup Linux
        post-steps:
          - report-coverage

    # Run E2E tests in Firefox with mobile device viewport
    - cypress/run:
        name: "UI Tests - Firefox - Mobile"
        browser: firefox
        spec: cypress/tests/ui/*
        config: viewportWidth=375,viewportHeight=667
        executor: with-chrome-and-firefox
        wait-on: "http://localhost:3000"
        yarn: true
        start: yarn start:ci
        record: true
        parallel: true
        parallelism: 5
        ci-build-id: ${CIRCLE_SHA1:0:8}
        group: "UI - Firefox - Mobile"
        requires:
          - Setup Linux
        post-steps:
          - report-coverage

windows-workflow: &windows-workflow
  jobs:
    # Setup
    #  1. Install Cypress
    #  2. Validate types
    #  3. Run server unit-tests
    - cypress/install:
        name: "Setup Windows"
        yarn: true
        executor:
          # executor comes from the "windows" orb
          name: win/default
          shell: bash.exe
        post-steps:
          - run:
              name: Cypress info
              command: yarn cypress info
          - run:
              name: Check Types
              command: yarn types
          - run:
              name: Run Unit Tests
              command: yarn test:unit:ci

    # Run E2E tests in Windows in Electron
    - cypress/run:
        name: "UI Tests - Electron - Windows"
        spec: cypress/tests/ui/*
        executor:
          # executor comes from the "windows" orb
          name: win/default
          shell: bash.exe
        wait-on: "http://localhost:3000"
        yarn: true
        start: yarn start:ci
        record: true
        parallel: true
        parallelism: 5
        ci-build-id: ${CIRCLE_SHA1:0:8}
        group: "UI - Electron - Windows"
        requires:
          - Setup Windows
        post-steps:
          - report-coverage
        no-workspace: true

workflows:
  linux:
    <<: *linux-workflow
  windows:
    <<: *windows-workflow




# PROMPT ZERO-SHOT - TESTES CYPRESS NOTIFICATIONS



## OBJETIVO

Gere um arquivo de teste Cypress funcional com 7 cenÃ¡rios de notificaÃ§Ãµes para Real World App.



## CONTEXTO TÃ‰CNICO

- Cypress v4/5: cy.route() + function syntax

- Imports: User, Transaction, isMobile

- Comandos: cy.getBySel(), cy.getBySelLike(), cy.loginByXstate(), cy.database(), cy.switchUser(), cy.createTransaction()

- Percy snapshots obrigatÃ³rios



## CENÃRIOS OBRIGATÃ“RIOS

1. User A likes transaction of User B â†’ User B gets notification

2. User C likes transaction between User A and User B â†’ Both get notifications

3. User A comments on transaction of User B â†’ User B gets notification

4. User C comments on transaction between User A and User B â†’ Both get notifications

5. User A sends payment to User B â†’ User B gets notification

6. User A sends payment request to User C â†’ User C gets notification

7. Renders empty notifications state



## REGRAS CRÃTICAS

- Function syntax (nÃ£o arrow functions)

- Login: cy.loginByXstate(ctx.userA.username)

- 3 usuÃ¡rios: ctx.userA, ctx.userB, ctx.userC

- Routes: cy.route("GET", "/notifications"), cy.route("POST", "/transactions"), cy.route("PATCH", "/notifications/*")

- Switch users: cy.switchUser(ctx.userB.username)

- Notifications: cy.getBySelLike("notifications-link").click() â†’ /notifications

- Badge count: cy.getBySel("nav-top-notifications-count")

- Notification items: cy.getBySelLike("notification-list-item").should("have.length", 9)

- Mark as read: cy.getBySelLike("notification-mark-read").first().click()

- Empty state: cy.route("GET", "/notifications", []) + cy.getBySel("empty-list-header")

- Mobile: isMobile() + cy.getBySel("sidenav-toggle").click()

- Actions: like button, comment input, createTransaction (payment/request)

- **PAYMENT NOTIFICATION:** User B receives payment â†’ notification shows User B.firstName + "received payment"



## RESULTADO

Gere um arquivo TypeScript completo com os 7 testes de notifications que rode sem erros no Real World App.